//@author: a0110670w



	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Add.cpp
	 */

#include "Add.h"

//To add floating and non-floating where the floating tasks
//If a clash (subject or time and date) is found, it will still add but a warning message will be output
bool Add::addContent(DataStore &data, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, bool isTemp) {
	if (data.get_tempEntry().subject == "") {
		return false;
	}

	if (!data.getData().empty() && !isTemp) {
		checkDuplicate(data, errMsg);
	}
	
	data.clearData(floating, scheduled, deadline);
	addToDataBase(data, isTemp, errMsg, floating, scheduled, deadline);
	return true;
}

//Checks if the date clashes
bool Add::isSameDate(DataStore data, int index) {
	if (data.getData()[index].year == data.get_tempEntry().year && data.getData()[index].month == data.get_tempEntry().month && data.getData()[index].day == data.get_tempEntry().day) {
		return true;
	}
	return false;
}

//Checks if time clashes
bool Add::isSameTime(DataStore data, int index) {
	int num1 = data.getData()[index].endTime;
	int num2 = data.get_tempEntry().endTime;

	//To take note of '12am' since it is considered 0 so that we can get the correct duration
	if (num1 == 0) {
		num1 = 2400;
	}
	if (num2 == 0) {
		num2 = 2400;
	}
	
	//To check if the tasks entered have overlapping times or not
	if (data.getData()[index].startTime == data.get_tempEntry().startTime) {
		return true;
	}
	if (data.getData()[index].startTime <= data.get_tempEntry().startTime) {
		if ((data.get_tempEntry().startTime - data.getData()[index].startTime) < (num1 - data.getData()[index].startTime)) {
			return true;
		}
	}
	if (data.getData()[index].startTime >= data.get_tempEntry().startTime) {
		 if ((data.getData()[index].startTime - data.get_tempEntry().startTime) < (num2 - data.get_tempEntry().startTime)) {
			return true;
		 }
	}
	return false;
}

//Outputs warning message if date or time has passed
void Add::checkDateTime(DataStore data, std::ostringstream &errMsg, bool pastDate, bool checkTime) {
	int index = 0;
	if (pastDate) {
		errMsg << std::endl << " WARNING: date entered has already undo (undo/edit adviced)";
	}
	if (checkTime && data.get_tempEntry().endTime > data.get_tempEntry().startTime && data.get_tempEntry().endTime != 0) {
		errMsg << std::endl << " end time entered earlier then start time (undo/edit adviced)";
	}
	return;
}

void Add::checkDuplicate(DataStore data, std::ostringstream &errMsg) {
	int index = 0;

	//Once a clash is found there is no need to search for further clashes since our program informs the user of any initial clashes already
	for (index = 0; index != data.getData().size(); index++) {
		if ((data.getData()[index].isFloat == data.get_tempEntry().isFloat) && (data.getData()[index].isTimedTask == data.get_tempEntry().isTimedTask)) {
			if (!data.getData()[index].isComplete) {
				if (data.getData()[index].subject == data.get_tempEntry().subject) {
					errMsg << std::endl << " WARNING: subject clash ";
					if (!data.getData()[index].isFloat && (isSameDate(data, index)) && (isSameTime(data, index))) {
						errMsg << "timing clash ";
					}
					errMsg << " (undo/edit adviced)";
					return;
				}
				else if (!data.getData()[index].isFloat && (isSameDate(data, index)) && (isSameTime(data, index))) {
					errMsg << std::endl << " WARNING: timing clash (undo/edit adviced)";
					return;
				}
			}
		}
	}
	return;
}

void Add::addToDataBase(DataStore &data, bool isTemp, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline) {
	Search search;
	
	//Empty
	if (data.getData().empty() && !isTemp) {
		data.getData().push_back(data.get_tempEntry());
	}
	else if (data.getTempData().empty() && isTemp) {
		data.getTempData().push_back(data.get_tempEntry());
	}
	//Float
	else if (data.get_tempEntry().isFloat) {
		addFloat(data, isTemp);
	}
	//Scheduled
	else if (data.get_tempEntry().isTimedTask && !data.get_tempEntry().isFloat) {
		if (!isTemp && !addScheduled(data, isTemp)) {
			data.getData().push_back(data.get_tempEntry());
		}
		else if (isTemp && !addScheduled(data, isTemp)) {
			data.getTempData().push_back(data.get_tempEntry());
		}
	}
	//Deadline
	else if (!data.get_tempEntry().isTimedTask && !data.get_tempEntry().isFloat) {
		if (!isTemp && !addDeadline(data, isTemp)) {
			data.getData().push_back(data.get_tempEntry());
		}
		else if (isTemp && !addDeadline(data, isTemp)) {
			data.getTempData().push_back(data.get_tempEntry());
		}
	}

	if (!isTemp) {
		search.getEntry(data, floating, scheduled, deadline, errMsg);
	}
	return;
}

bool Add::addScheduled(DataStore &data, bool isTemp) {
	std::vector <Entry>::iterator iter;
	std::vector <Entry> check;
	int index = 0;

	selectDataBase(data, check, isTemp);
	for (iter = check.begin(); iter !=check.end(); iter++) {
		if ((*iter).isTimedTask) {
			if (isAdded(data, check, iter, index, isTemp)) {
				revertDataBase(data, check, isTemp);
				return true;
			}
		}
		if ((*iter).isTimedTask && (*iter).isComplete) {
			check.insert(iter, data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return true;
		}
		if (!(*iter).isFloat && !(*iter).isTimedTask) { 
			check.insert(iter, data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return true;
		}
		index++;
	}
	return false;
}

bool Add::addDeadline(DataStore &data, bool isTemp) {
	std::vector <Entry>::iterator iter;
	std::vector <Entry> check;
	int index = 0;

	selectDataBase(data, check, isTemp);
	for (iter = check.begin(); iter != check.end(); iter++) {
		if (!(*iter).isTimedTask && !(*iter).isFloat && !(*iter).isComplete) {
			if (isAdded(data, check, iter, index, isTemp)) {
				revertDataBase(data, check, isTemp);
				return true;
			}
		}
		if ((!(*iter).isTimedTask && !(*iter).isFloat) && (*iter).isComplete) { 
			check.insert(iter, data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return true;
		}
		index++;
	}
	return false;
}

void Add::addFloat(DataStore &data, bool isTemp) {
	std::vector <Entry>::iterator iter;
	std::vector <Entry> check;
	int index = 0;
	
	selectDataBase(data, check, isTemp);	
	for (iter = check.begin(); iter != check.end(); iter++) {
		if ((*iter).isFloat && !(*iter).isComplete && isAdded(data, check, iter, index, isTemp)) {
			revertDataBase(data, check, isTemp);
			return;
		}
		if (((*iter).isFloat && (*iter).isComplete)) { 
			check.insert(iter, data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return;
		}
		if (!(*iter).isFloat) {	
			check.insert(iter, data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return;
		}
		if ((iter + 1) == check.end()) {
			check.push_back(data.get_tempEntry());
			revertDataBase(data, check, isTemp);
			return;
		}
		index++;
	}
	return;
}

bool Add::isAdded(DataStore &data, std::vector <Entry> &check, std::vector <Entry>::iterator iter, int index, bool isTemp) {
	if (isSameDate(data, index) && !isTemp) {
		if ((*iter).startTime > data.get_tempEntry().startTime) {
			check.insert(iter, data.get_tempEntry());
			return true;
		}
		else if ((*iter).startTime == data.get_tempEntry().startTime) {
			if ((*iter).endTime > data.get_tempEntry().endTime) {
				check.insert(iter, data.get_tempEntry());
				return true;
			}
		}
	}
	//Cmp day
	else if (((*iter).year == data.get_tempEntry().year) && ((*iter).month == data.get_tempEntry().month) && ((*iter).day > data.get_tempEntry().day)) {
		if (!isTemp) {
			check.insert(iter, data.get_tempEntry());
		}
		else {
			check.insert(iter, data.get_tempEntry());
		}
		return true;
	}
	//Cmp month
	else if (((*iter).year == data.get_tempEntry().year) && ((*iter).month > data.get_tempEntry().month)) {
		if (!isTemp) {
			check.insert(iter, data.get_tempEntry());
		}
		else {
			check.insert(iter, data.get_tempEntry());
		}
		return true;
	}
	//Cmp year
	else if (((*iter).year > data.get_tempEntry().year)) {
		if (!isTemp) {
			check.insert(iter, data.get_tempEntry());
		}
		else {
			check.insert(iter, data.get_tempEntry());
		}
		return true;
	}
	return false;
}

void Add::selectDataBase(DataStore &data, std::vector <Entry> &check, bool isTemp) {
	if (!isTemp) {
		check = data.getData();
	}
	else {
		check = data.getTempData();
	}
	return;
}

void Add::revertDataBase(DataStore &data, std::vector <Entry> &check, bool isTemp) {
	if (!isTemp) {
		data.getData() = check;
	}
	else {
		data.getTempData() = check;
	}
	return;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Add.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Add.h
	 */

#ifndef ADD_H
#define ADD_H

#include "DataStore.h"
#include "Search.h"

class Add {
	public:
		Add() {};

		bool addContent(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, bool);
	
		void checkDuplicate(DataStore, std::ostringstream &);
		void checkDateTime(DataStore, std::ostringstream &, bool, bool);
		bool isSameDate(DataStore, int);
		bool isSameTime(DataStore, int);

		void addToDataBase(DataStore &, bool, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		bool addScheduled(DataStore &, bool);
		bool addDeadline(DataStore &, bool);
		void addFloat(DataStore &, bool);

		bool isAdded(DataStore &, std::vector <Entry> &, std::vector <Entry>::iterator, int, bool);

		void selectDataBase(DataStore &, std::vector <Entry> &, bool);
		void revertDataBase(DataStore &, std::vector <Entry> &, bool);
		void getIndex(DataStore &, std::vector <Entry> &, int);
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Add.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Classes.cpp
	 */

#include "Classes.h"

int Classes::determineCommand(std::string _userInput) {
	if (_userInput == "add" || _userInput == "1" || _userInput == "addto" || _userInput == "-") {
		return commandType::ADD;
	}
	else if (_userInput == "display" || _userInput == "2" || _userInput == "search" || _userInput == "show" || _userInput == "find" || _userInput == "get") {
		return commandType::SEARCH;
	}
	else if (_userInput == "delete" || _userInput == "3" || _userInput == "remove" || _userInput == "del") {
		return commandType::REMOVE;
	}
	else if (_userInput == "clear" || _userInput == "4" || _userInput == "reset" || _userInput == "clr" || _userInput == "addto") {
		return commandType::CLEAR;
	}
	else if (_userInput == "edit" || _userInput == "5" || _userInput == "append" || _userInput == "change" || _userInput == "check" || _userInput == "done" || _userInput == "complete" || _userInput == "completed" || _userInput == "uncheck" || _userInput == "uncomplete") {
		return commandType::EDIT;
	}
	else if (_userInput == "sort" || _userInput == "6") {
		return commandType::SORT;
	}
	else if (_userInput == "exit" || _userInput == "7") {
		return commandType::EXIT;
	}
	else if (_userInput == "undo" || _userInput == "back") {
		return commandType::UNDO;
	}
	else if (_userInput == "redo" || _userInput == "front" || _userInput == "forward") {
		return commandType::REDO;
	}
	else {
		return commandType::INVALID;
	}
}

int Classes::determineField(std::string info) {
	if (info == "date") {
		return fieldType::DATE;
	}
	else if (info == "time") {
		return fieldType::TIME;
	}
	else if (info == "priority" || info == "impt" || info == "importance") {
		return fieldType::PRIORITY;
	}
	else if (info == "category" || info == "cat") {
		return fieldType::CATEGORY;
	}
	else if (info == "sub" || info == "subject" || info == "alphabetically") {
		return fieldType::SUBJECT;
	}
	else {
		return fieldType::INVALIDFIELD;
	}
}

int Classes::determinePriority(std::string str) {
	if (str == "LOW" || str == "L") {
		return priorityType::LOW;
	}
	else if (str == "MEDIUM" || str == "MED" || str == "M") {
		return priorityType::MEDIUM;
	}
	else if (str == "HIGH" || str == "H") {
		return priorityType::HIGH;
	}
	else {
		return priorityType::PINVALID;
	}
}

int Classes::determineCategory(std::string word) {
	if (word == "WORK     " || word == "WORK") {
		return catType::WORK;
	}
	else if (word == "PERSONAL " || word == "PERSONAL") {
		return catType::PERSONAL;
	}
	else if (word == "ERRAND   " || word == "ERRAND") {
		return catType::ERRAND;
	}
	else if (word == "GENERAL " || word == "GENERAL") {
		return catType::GENERAL;
	}
	else {
		return catType::CINVALID;
	}
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Classes.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Classes.h
	 */

#ifndef CLASSES_H
#define CLASSES_H

#include "Timing.h"
#include "Date.h"
#include "Add.h"
#include "Priority.h"
#include "Category.h"
#include "Clear.h"
#include "Delete.h"
#include "Edit.h"
#include "Sort.h"
#include "Search.h"
#include "Log.h"

class Classes {
	public:
		enum commandType {
			ADD, SEARCH, CLEAR, EDIT, SORT, REMOVE, DO_NOTHING, UNDO, REDO, INVALID, EXIT
		};

		enum fieldType {
			SUBJECT, DATE, TIME, PRIORITY, CATEGORY, INVALIDFIELD
		};

		enum priorityType {
			LOW, MEDIUM, HIGH, PINVALID
		};

		enum catType {
			WORK, PERSONAL, ERRAND, GENERAL, CINVALID
		};

		Classes () {};
		Add add;
		Delete remove;
		Search search;
		Edit edit;
		Sort sortFile;
		Clear clearFile;
		Timing time;
		Date date;
		Priority priority;
		Category category;
		Log log;

		int determineCommand(std::string);
		int determineField(std::string);
		int determinePriority(std::string);
		int determineCategory(std::string);
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Classes.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Date.cpp
	 */

#include "Date.h"
#include "Timing.h"

int Date::determineMonth(std::string str) {	
	if (str == "jan" || str == "january") {
		return monthType::JAN;
	}
	else if (str == "feb" || str == "february") {
		return monthType::FEB;
	}
	else if (str == "mar" || str == "march") {
		return monthType::MAR;
	}
	else if (str == "apr" || str == "april") {
		return monthType::APR;
	}
	else if (str == "may") {
		return monthType::MAY;
	}
	else if (str == "jun" || str == "june") {
		return monthType::JUN;
	}
	else if (str == "jul" || str == "july") {
		return monthType::JUL;
	}
	else if (str == "aug" || str == "august") {
		return monthType::AUG;
	}
	else if (str == "sep" || str == "september") {
		return monthType::SEP;
	}
	else if (str == "oct" || str == "october") {
		return monthType::OCT;
	}
	else if (str == "nov" || str == "november") {
		return monthType::NOV;
	}
	else if (str == "dec" || str == "december") {
		return monthType::DEC;
	}
	else {
		return monthType::INVALIDMONTH;
	}
}

int Date::determineDay(std::string &str) {	
	if (str == "mon" || str == "monday") {
		str = "Monday";
		return dayType::MON;
	}
	else if (str == "tue" || str == "tuesday") {
		str = "Tuesday";
		return dayType::TUE;
	}
	else if (str == "wed" || str == "wednesday") {
		str = "Wednesday";
		return dayType::WED;
	}
	else if (str == "thur" || str == "thursday") {
		str = "Thursday";
		return dayType::THUR;
	}
	else if (str == "fri" || str == "friday") {
		str = "Friday";
		return dayType::FRI;
	}
	else if (str == "sun" || str == "sunday") {
		str = "Sunday";
		return dayType::SUN;
	}
	else if (str == "sat" || str == "saturday") {
		str = "Saturday";
		return dayType::SAT;
	}
	else {
		return dayType::INVALIDDAY;
	}
}

//To make entering the month not case-sensitive
void Date::changeToLower(std::string &str) {
	int i;
	for (i = 0; i < str.size(); i++) {
		if (str[i] >= 'A' && str[i] <= 'Z') {
			str[i] = 'a' + (str[i] - 'A');	
		}
	}
	return;
}

void Date::removeNonDateChar(std::string &str) {
	size_t found;
	found = str.find_first_of(" ");

	while (found != std::string::npos && found == 0) {
		str = str.substr(1);
		found = str.find_first_of(" ");
	}
	return;
}

//To return possible date values only
bool Date::extractNum(std::string tStr, int &count, int &num) {
	size_t end = 0;
	while (end != std::string::npos && (tStr[end] >= '0' && tStr[end] <= '9')) {
		if (end == count) {
			num = (num * 10) + (tStr[end] - '0');
			count++;
		}
		else {
			break;
		}
		if ((end + 1) == tStr.size()) {
			end = std::string::npos;
		}
		else {
			end = tStr.find_first_of("0123456789", end + 1);
		}
		
	}

	if (count <= 4 && num != 0) {
		return true;
	}
	return false;
}

//To take into acc for 1st 2nd 3rd 12th etc
void Date::removeExtraLetters(std::string str, int &count) {
	changeToLower(str);
	size_t i = str.find("th", count);
	size_t j = str.find("st", count);
	size_t k = str.find("nd", count);
	size_t l = str.find("rd", count);
	if (i != std::string::npos || j != std::string::npos || k != std::string::npos || l != std::string::npos) {
		if (i == count || j == count || k == count || l == count) {
			count = count + 2;
		}
	}
	return;
}

bool Date::retrieveDayIfNext(std::string &dateDayWord, size_t end, std::string str) {
	if (dateDayWord == "next") {
		if (end != std::string::npos) {
			dateDayWord = str.substr(end + 1);
			end = dateDayWord.find_first_of(" ");
			if (end != std::string::npos) {
				dateDayWord = dateDayWord.substr(0, end);
			}
			return true;
		}
		else {
			return false;
		}
	}
	return false;
}

bool Date::getDayOfWeek(std::string dateDayWord, tm now, int count) {
	changeToLower(dateDayWord);
	int dayWord = determineDay(dateDayWord);
	int i = 0;
	struct tm *timeInfo;
	const char *weekday[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
	timeInfo = &now;

	if (dayWord != dayType::INVALIDDAY) {
		for (;;) {
			mktime(timeInfo);
			if (weekday[timeInfo->tm_wday] == dateDayWord) {
				if (count == 1 && i > 7) {
					break;
				}
				else if (count == 0) {
					break;
				}
			}
			timeInfo->tm_mday = timeInfo->tm_mday + 1;
			i++;
		}
		_day = timeInfo->tm_mday;
		_month = timeInfo->tm_mon + 1;
		_year = timeInfo->tm_year + 1900;
		return true;
	} 
	return false;
}

bool Date::getTdyTmr(std::string dateWord,tm now, bool &pastDate) {
	changeToLower(dateWord);
	if (dateWord == "today" || dateWord == "tdy" || dateWord == "tday" || dateWord == "later" || dateWord == "tonight") {
		_day = (now.tm_mday);
	}
	else if (dateWord == "tomorrow" || dateWord == "tmr" || dateWord == "tomoro" || dateWord == "tmrw") {
		_day = (now.tm_mday) + 1;
	}
	else {
		return false;
	}
	_month = (now.tm_mon + 1);
	_year = (now.tm_year + 1900);

	if (!isValidDate(pastDate)) {
		_day = 1;
		_month++;
	}
	return true;
}

bool Date::dateInLetter(std::string &str) {
	size_t end = str.find_first_of(" ");
	std::string dateDayWord = "";
	int count = 0;
	bool pastDate = false;
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);

	if (end == std::string::npos) {
		dateDayWord = str;
	}
	else {
		dateDayWord = str.substr(0, end);
	}	

	//Exception for sat and wed and sun
	if (dateDayWord == "sat" || dateDayWord == "sun" || dateDayWord == "wed") {
		return false;
	}

	//If current word is 'next' get the next word to check for day of the week
	if (retrieveDayIfNext(dateDayWord, end, str)) {
		count++;
	}
	
	if (getDayOfWeek(dateDayWord, now, count)) {
		if (count == 1) {
			str = str.substr(end + 1);
			end = str.find_first_of(" ");
		}
	}
	else if (!getTdyTmr(dateDayWord, now, pastDate)) {
		return false;
	}

	if (end == std::string::npos) {
		str = "";
	}
	else {
		str = str.substr(end + 1);
	}
	return true;
}

//To identify a potential day
bool Date::takeDay(std::string &tStr, size_t &start) {
	int count = 0;

	if (!extractNum(tStr, count, _day)) {
		return false;
	}
	else {
		if (count > 2) {
			return false;
		}
		removeExtraLetters(tStr, count);
		start = count;
		return true;
	}
}

//To identify a potential month
bool Date::takeMonth(std::string &tStr, size_t &start, size_t &end) {
	int count = 0;
	std::string str = "";
	start = tStr.find_first_of("0123456789");

	//If month is in numbers
	if (start != std::string::npos && start == 1 && tStr[0] == '/') {
		tStr = tStr.substr(1);
		if (!extractNum(tStr, count, _month)) {
			return false;
		}
		else if (count > 2) {
			return false;
		}
		end = count;
	}
	//If month is in words
	else {
		end = tStr.find_first_of(" 1234567890");
		if (end == std::string::npos) {
			end = tStr.size();
		}
		str = tStr.substr(0, end);
		changeToLower(str);
		_month = determineMonth(str);
		if (_month == 13) {
			return false;
		}
	}
	start = end;
	return true;
}

//To identify if any year entered, else default year will be the current year
void Date::takeYear(std::string &tStr, std::string newStr, std::string originalStr, size_t start) {
	int noOfTime = 0;
	std::string str = newStr;
	int count = 0;
	bool checkTime = false;
	size_t index = originalStr.find_first_of(" ", (originalStr.find(newStr) + 5));
	
	Timing timer;
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);

	//Cut off DD/MM
	tStr = newStr;

	if (!extractNum(newStr, count, _year)) {
		_year = (now.tm_year + 1900);
		return;
	}
	else if (originalStr[originalStr.find(newStr) - 1] == '/') {
		if (count == newStr.size()) {
			tStr = "";
		}
		else if (count == 2 || count == 4) {
			tStr = newStr.substr(count);
			if (count == 2) {
				_year = _year + 2000;
			}
		}
		return;
	}
	else if (count != 4) {
		_year = (now.tm_year + 1900);
		return;
	}
	//Listful can only accept tasks up to 50 years in the redo and 10 years back
	else if (_year < (now.tm_year + 1890) || _year > (now.tm_year + 1950)) {
		_year = (now.tm_year + 1900);
		return;
	}
	else if (_year >= (now.tm_year + 1900) && _year <= (now.tm_year + 1900) + 5) {
		if (count == newStr.size()) {
			tStr = "";
		}
		else {
			tStr = newStr.substr(count);
		}
		return;
	}
	else {
		if (index != std::string::npos) {
			std::string findTime = originalStr.substr((originalStr.find(newStr) + 4), index - (originalStr.find(newStr) + 4));
			changeToLower(findTime);
			removeNonDateChar(findTime);
			if (findTime[0] == '-' || findTime == "to" ||  findTime == "am" || findTime == "pm" || findTime == "a.m" || findTime == "p.m" || findTime == "a.m." || findTime == "p.m.") {
				_year = (now.tm_year + 1900);
				return;
			}
		}

		//To check if the number after the month is a year or a time
		timer.removeNonTimeChar(str);
		if (timer.checkForTime(str, noOfTime, checkTime)) {
			index = 0;
			//If any time is found before this '_year' then _year is a real year
			str = originalStr.substr(0, originalStr.find_last_of(" ", start));
			while (index != std::string::npos && index < start) {
				noOfTime = 0;
				index = str.find_first_of(" ", index);
				if (index != std::string::npos) {
					index = str.find_first_not_of(" ", index);
					str = str.substr(index);
				}
				if (timer.checkForTime(str, noOfTime, checkTime)) {
					if (count == newStr.size()) {
						tStr = "";
					}
					else {
						tStr = newStr.substr(count);
					}
					return;
				}
			}
				
			index = 0;
			//If a timed task timing is found after the year then _year is a real year
			if (count != newStr.size()) {
				str = newStr.substr(count);
				timer.removeNonTimeChar(str);
				while (index != std::string::npos) {
					noOfTime = 0;
					index = str.find_first_of(" ", index);
					if (index != std::string::npos) {
						index = str.find_first_not_of(" ", index);
						str = str.substr(index);
					}
					if (timer.checkForTime(str, noOfTime, checkTime)) {
						tStr = newStr.substr(count);
						return;
					}
				}
			}
		}
	}
	return;
}

//To invalidate dates like the 32th dec
bool Date::isValidDate(bool &pastDate) {
	if (_month > 12) {
		return false;
	}
	else if (_month == 2 && _day > 29) {
		return false;
	}	
	else if ((_month < 8 && _month%2 == 1) || (_month > 7 && _month%2 == 0)) {
		if (_day > 31) {
			return false;
		}
	}
	else if (_day > 30) {
			return false;
	}
	else {
		//Get current date
		time_t t = time(0);   
		struct tm now;
		localtime_s(&now, &t);
		if (_year < (now.tm_year + 1900)) {
			pastDate = true;
		}
		else if (_year == (now.tm_year + 1900) && _month < (now.tm_mon + 1)) {
			pastDate = true;
		}
		else if (_year == (now.tm_year + 1900) && _month == (now.tm_mon + 1) && _day < (now.tm_mday)) {
			pastDate = true;
		}
	}
	return true;
}

//To identify if the current first word of the string is a date
bool Date::checkForDate(std::string &tStr, bool &pastDate, std::string originalStr, size_t index, bool getNewDate) {
	_day = 0;
	_month = 0;
	_year = 0;
	std::string newStr = "";
	std::string newDate = "";
	size_t start = 0;
	size_t end = 0;
	pastDate = false;

	//DD/MM
	if (takeDay(tStr, start)) {
		newStr = tStr.substr(start);
		removeNonDateChar(newStr);
		if (!takeMonth(newStr, start, end)) {
			return false;
		}
		else {
			newStr = newStr.substr(start);
			removeNonDateChar(newStr);
			if (newStr != "" && newStr[0] == '/') {
				newStr = newStr.substr(1);
			}
			takeYear(tStr, newStr, originalStr, index);
		}
	}
	//MM/DD
	else if (takeMonth (tStr, start, end)) {
		newStr = tStr.substr(start);
		removeNonDateChar(newStr);
		if (!takeDay(newStr, start)) {
			return false;
		}
		else {
			newStr = newStr.substr(start);
			removeNonDateChar(newStr);
			if (newStr != "" && newStr[0] == '/') {
				newStr = newStr.substr(1);
			}
			takeYear(tStr, newStr, originalStr, index);
		}
	}
	else if (dateInLetter(tStr)) {
		return true;
	}
	else {
		return false;
	}
	//If user is entering a date but it is wrong due to typo
	if (!isValidDate(pastDate) && !getNewDate) {
		std::cout << " possible date [ " << _day << '/' << _month << " ] entered but invalid\n\n new date?\n\n ";
		getline(std::cin, newDate);
		getNewDate = true;
		if (newDate == "") {
			return	false;
		}
		return checkForDate(newDate, pastDate, originalStr, index, getNewDate);
	}
	return true;
}

int &Date::getDay() {
	return _day;
}

int &Date::getMonth() {
	return _month;
}

int &Date::getYear() {
	return _year;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Date.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Date.h
	 */

#ifndef DATE_H
#define DATE_H

#include "DataStore.h"

class Date {
	private:
		enum monthType {
			JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC, INVALIDMONTH
		};

		enum dayType {
			SUN, MON, TUE, WED, THUR, FRI, SAT, INVALIDDAY
		};

		int _day;
		int _month;
		int _year;

	public:
		Date() {};

		int determineMonth(std::string);
		int determineDay(std::string &);
		
		void changeToLower(std::string &);
		void removeNonDateChar(std::string &);
		bool extractNum(std::string, int &, int &);
		void removeExtraLetters(std::string, int &);
		bool retrieveDayIfNext(std::string &, size_t, std::string);
		bool getDayOfWeek(std::string, tm, int);
		bool getTdyTmr(std::string,tm, bool &);
		bool dateInLetter(std::string &);
		
		bool takeDay(std::string&, size_t &);
		bool takeMonth(std::string&, size_t &, size_t &);
		void takeYear(std::string &, std::string, std::string, size_t);
		bool isValidDate(bool &);
		
		bool checkForDate(std::string &, bool &, std::string, size_t, bool);

		int &getDay();
		int &getMonth();
		int &getYear();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Date.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\FileLocation.cpp
	 */

#include "FileLocation.h"

const std::string FileLocation::FILE_LOCATION_LIST = "Listful_FileLocationList.txt";

//Shifts accessed file to the top
void FileLocation::updateFileLocation(std::string x) {
	std::string name = "";
	std::vector <std::string> fileList;
	
	fileList.push_back(x);

	//Retrieve the rest of the locations
	std::ifstream readFile(FILE_LOCATION_LIST.c_str());
	if (readFile.is_open()) {
		while (!readFile.eof()) {
			getline(readFile, name);
			if (name != x && name != "") {
				fileList.push_back(name);
			}
		}
		readFile.close();
	}
	updateOpenFile(fileList);
	return;
}

//To retrieve previously saved file names and location
void FileLocation::saveFileLocation() {
	std::string name = "";
	std::vector <std::string> fileList;
	std::string find = _fileName.substr(_fileName.find_last_of("\\") + 1);
					
	fileList.push_back(_fileName);

	//To copy the already saved file names so that it will not be overwritten
	std::ifstream readFile(FILE_LOCATION_LIST);
	if (readFile.is_open()) {
		while (!readFile.eof()) {
			getline(readFile, name);
			if (name != "") {
				fileList.push_back(name);
			}
		}
		readFile.close();
	}
	updateOpenFile(fileList);
	return;
}



//To write the locations back into open file
void FileLocation::updateOpenFile(std::vector <std::string> fileList) {
	std::ofstream writeFile(FILE_LOCATION_LIST.c_str());
	if (writeFile.is_open()) {
		while (!fileList.empty()) {
			writeFile << *(fileList.begin()) << "\n";
			fileList.erase(fileList.begin());
		}
		writeFile.close();
	}
	return;
}



bool FileLocation::isFileFound(DataStore &data, bool isOpen) {
	std::string x = "";
	std::string find = "";
	size_t found = 0;

	std::ifstream readFile(FILE_LOCATION_LIST.c_str());
	if (readFile.is_open()) {
		while (!readFile.eof()) {
			getline(readFile, x);

			//If file has no name entered, open last accessed file
			if (!isOpen) {
				isOpen = true;
				find = _fileName.substr(_fileName.find_last_of("\\") + 1);
				if (find == ".txt") {
					_fileName = x;
					return true;
				}
			}

			//If file has no location specified and a file with the same name is found in this list, 
			//assume user is referring to the same file
			found = x.find(_fileName);
			if (x == _fileName || found != std::string::npos) {
				_fileName = x;
				updateFileLocation(x);
				return true;
			}
		}
		readFile.close();
	}
	saveFileLocation();
	if (isFileFound(data, isOpen)) {
		return true;
	}
	return false;
}

int FileLocation::openFile(DataStore &data, ParserFacade parse, Classes &listClass) {
	std::string x = "";
	std::string subject = "";
	size_t start = 0;
	size_t end = 0;
	int i = 0;
	bool ignore = false;
	
	if (isFileFound(data, ignore)) {
		std::ifstream readFile(_fileName.c_str());
		if (readFile.is_open()) {
			while (!readFile.eof()) {
				getline(readFile, x);

				//If there are extra lines inbetween the files
				while (x == "") {
					getline(readFile, x);
					i++;
					if (i > 10) {
						data.updateFile(data);
						data.savePrevFile();
						readFile.close();
						return fileMsg::OPEN;
					}
				}
				subject = x.substr(x.find_first_of(".") + 1, (x.find(" | ") - (x.find_first_of(".") + 1)));
				parse.removeFrontChar(subject);
				parse.removeBackChar(subject);
				
				x = x.substr(x.find_first_of("|"));
				parse.readFile(x);
				parse.separateWord(data, ignore, ignore);
				
				data.get_tempEntry().subject = subject;
				data.getData().push_back(data.get_tempEntry());

				//Removes extra line in between entries
				getline(readFile, x);
			}
			data.updateFile(data);
			data.savePrevFile();
			readFile.close();
			return fileMsg::OPEN;
		}
	}
	data.updateFile(data);
	return fileMsg::CREATE;
}



std::string &FileLocation::getName() {
	return _fileName;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\FileLocation.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\FileLocation.h
	 */

#ifndef FILELOCATION_H
#define FILELOCATION_H

#include "ParserFacade.h"

class FileLocation {
	private:
		static const std::string FILE_LOCATION_LIST;

		enum fileMsg {
			OPEN, CREATE
		};

		std::string _fileName;

	public:
		FileLocation() {};
	
		void updateFileLocation(std::string);
		void saveFileLocation();

		void updateOpenFile(std::vector <std::string>);

		bool isFileFound(DataStore &, bool);
		int openFile(DataStore &, ParserFacade, Classes &);

		std::string &getName();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\FileLocation.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Timing.cpp
	 */

#include "Timing.h"

Timing::Timing() {
	_startTime = 0;
	_endTime = 0;
	
	_linkWord.push_back("-");
	_linkWord.push_back("to");
	_linkWord.push_back("till");
	_linkWord.push_back("until");
	_linkWord.push_back("up to");
	_linkWord.push_back("up till");
	_linkWord.push_back("up until");
}



bool Timing::extractNum (std::string line, int &count, int &num) {
	size_t end = 0;
	int noOfMin = 0;

	//If time is in 7.00 or 7:00 format for example
	size_t nonNum = line.find_first_of(".:");
	if (nonNum != std::string::npos && nonNum > 2) {
		nonNum = std::string::npos;
	}

	while (end != std::string::npos  && (line[end] >= '0' && line[end] <= '9')) {
		if (end == count) {
			num = (num * 10) + (line[end] - '0');
			count++;
		}
  		else if ((end == count + 1) && nonNum != std::string::npos) {
			num = (num * 10) + (line[end] - '0');
			count++;
			noOfMin++;
		}
		else {
			break;
		}

		if ((end + 1) == line.size()) {
			end = std::string::npos;
		}
		else {
			end = line.find_first_of("0123456789", end + 1);
		}
	}
	if (count == 1 && num == 0) {
		return false;
	}
	else if (nonNum != std::string::npos && noOfMin != 2) {
		return false;
	}
	else if (nonNum != std::string::npos) {
		count++;
		return true;
	}
	else if (count <= 4 && count != 0 && num < 2400) {
		return true;
	}
	return false;
}

bool Timing::checkForTime (std::string &line, int &noOfTime, bool &checkTime) {
	std::string str = line;
	size_t index = 0;
	size_t index2 = 0;
	int noOfWord = 0;

	if (takeTime(str, noOfTime, checkTime)) {
		removeNonTimeChar(str);
		line = str;
		countWord(str, noOfWord);
		if (noOfWord > 3) {
			return true;
		}
		else {
			int temp = noOfWord;
			while (index != std::string::npos && noOfWord > 0) {
				index = str.find_first_of(" -", index);
				if(str[index] == '-') {
					index++;
				}
				else if (index != std::string::npos) {
					index = str.find_first_not_of(" -", index);
				}

				str = str.substr(index);
				removeNonTimeChar(str);
				noOfWord--;
			}
			if (temp != 0 && takeTime(str, noOfTime, checkTime)) {
				checkTime = false;
				checkTime = checkStartEnd();
				line = str;
				return true;
			}
			else {
				line = str;
				return true;
			}
		}
	}
	return false;
}

bool Timing::takeTime(std::string &line, int &noOfTime, bool &checkTime) {
	int count = 0;
	int time = 0;

	if (!extractNum(line, count, time)) {
		return false;
	}

	checkAMPM(line, count, time, checkTime, noOfTime);

	if (!checkTime && time < 100 && count < 4) {
		return false;
	}
	else if (!(isTimeValid(time))) {
		return false;
	}
	else if (noOfTime == 0) {
		_startTime = time;
		noOfTime++;
		time = 0;
	}
	else if (noOfTime == 1) {
		_endTime = time;
		noOfTime++;
	}
	return true;
}

void Timing::checkAMPM (std::string &originalStr, int count, int &num, bool &checkTime, int noOfTime) {
	std::string line = originalStr;
	std::string remainingStr = originalStr.substr(count);
	changeToLower(line);
	
	size_t foundAM = line.find("am");
	size_t foundAM2 = line.find("a.m");
	size_t foundPM = line.find("pm");
	size_t foundPM2 = line.find("p.m");
	size_t i = line.find("-");
	size_t j = line.find("to");
	checkTime = false;
	
	if (foundAM != std::string::npos && ((foundAM - count) < 2)) {
		if (count <= 2 && num == 12) {
			num = 0;
		}
		else if (count <= 2) {
			num = num * 100;
		}
		else if (num == 1200) {
			num = 0;
		}
		extractRemainingStr(originalStr, line, foundAM);
		checkTime = true;
	}
	else if (foundAM2 != std::string::npos && ((foundAM2 - count) < 2)) {
		if (count <= 2 && num == 12) {
			num = 0;
		}
		else if (count <= 2) {
			num = num * 100;
		}
		extractRemainingStr(originalStr, line, foundAM2);
		checkTime = true;
	}
	else if (foundPM != std::string::npos && ((foundPM - count) < 2)) {
		if (count <= 2) {
			num = (num * 100) + 1200;
		}
		else {
			num = num + 1200;
		}
		extractRemainingStr(originalStr, line, foundPM);
		checkTime = true;
	}
	else if (foundPM2 != std::string::npos && ((foundPM2 - count) < 2)) {
		if (count <= 2) {
			num = (num * 100) + 1200;
		}
		else {
			num = num + 1200;
		}
		extractRemainingStr(originalStr, line, foundPM2);
		checkTime = true;
	}
	//assume pm if not indicated
	else {
		if ((count > 2 && count < 4) || (num > 100 && num < 959 && count == 4)) {
			num = num + 1200;
		}
		else if (count <= 2) {
			if (i != std::string::npos || j != std::string::npos || noOfTime == 1) {
				while (remainingStr[0] == ' ') {
					remainingStr = remainingStr.substr(1);
					count++;
				}
				if ((i - count) <= 1 || (j - count) <= 1 || noOfTime == 1) {
					if (num == 12) {
						num = num * 100;
					}
					else {
						num = (num * 100) + 1200;
						checkTime = true;
					}
				}
			}
		}

		if (count != line.size()) {
			originalStr = originalStr.substr(count);
		}
		else {
			originalStr = "";
		}
	}

	if (num == 2400) {
		num = 1200;
	}
	return;
}



//Count no. of words between two possible times
void Timing::countWord(std::string str, int &noOfWord) {
	size_t nextTime = str.find_first_of("0123456789");
	size_t found = str.find_first_of(",.?!");
	if (found != std::string::npos && found < nextTime) {
		return;
	}
	
	size_t found2 = str.find_first_of("-");
	if (found2 != std::string::npos && found2 < 2 && found2 < nextTime) {
		noOfWord = 1;
		return;
	}
	
	size_t index = str.find_first_of(" ");
	for (int i = _linkWord.size() - 1; i >= 0; i--) {
		size_t found = str.find(_linkWord[i]);
		if (found != std::string::npos && found <= index + 1) {
			while (index != std::string::npos && nextTime != std::string::npos) {
				if (index < nextTime) {
					noOfWord++;
					index = str.find_first_of(" ", index + 1);
					if (index != std::string::npos) {
						index = str.find_first_not_of(" ", index);
					}
				}
				else {
					return;
				}
			}
		}
	}
	return;
}

void Timing::changeToLower(std::string &str) {
	int i = 0;
	for (i = 0; i < str.size(); i++) {
		if (str[i] >= 'A' && str[i] <= 'Z') {
			str[i] = 'a' + (str[i] - 'A');
		}
	}
	return;
}

//Cuts off 'am' and 'pm'
void Timing::extractRemainingStr(std::string &originalStr, std::string &line, size_t found) {
	size_t space = line.find_first_of(" -", found + 2);

	if (space == std::string::npos) {
		originalStr = "";
	}
	else {
		line = line.substr(space);
		originalStr = originalStr.substr(originalStr.size() - line.size());
	}
	return;
}

bool Timing::isTimeValid(int num) {
	assert(num>=0);

	if (num/100 > 23) {
		return false;
	}
	
	if (num%100 > 59) {
		return false;
	}
	return true;
}

//Assume that the task will be adeadline task if only one time is entered
void Timing::removeNonTimeChar(std::string &str) {
	size_t found;
	found = str.find_first_of(" ");

	while (found != std::string::npos && found == 0) {
		str = str.substr(1);
		found = str.find_first_of(" ");
	}
	return;
}



void Timing::updateTime() {
	_endTime = _startTime;
	return;
}

bool Timing::checkStartEnd() {
	int eTime = _endTime;
	if (eTime == 0) {
		eTime = 2400;
	}
	if (eTime < _startTime) {
		return true;
	}
	return false;
}



int &Timing::getStart() {
	return _startTime;
}

int &Timing::getEnd() {
	return _endTime;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Timing.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Timing.h
	 */

#ifndef TIMING_H
#define TIMING_H

#include "DataStore.h"

class Timing {
	private:
		std::vector <std::string> _linkWord;
		int _startTime;
		int _endTime;

	public:
		Timing();
		
		bool checkForTime (std::string &, int &, bool &);
		
		bool takeTime(std::string &, int &, bool &);
		void checkAMPM (std::string &, int , int &, bool &, int);
		bool isTimeValid(int);
		bool extractNum (std::string, int &, int &);
		
		void countWord(std::string, int &);
		void changeToLower(std::string &);
		void extractRemainingStr(std::string &, std::string &, size_t);
		void removeNonTimeChar(std::string &);
		
		void updateTime();
		bool checkStartEnd();
		
		int &getStart();
		int &getEnd();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Timing.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp
	 */

	TEST_CLASS(ListFulRemainingTest) {
	public:
		
		TEST_METHOD(TimeBoundaryTest)
		{
			// TODO: Your test code here
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string input1 = "add 0000-2359 TY's bday 1st apr 2015";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);

			int expectedStartTime = 0;
			int actualStartTime = data.getData()[0].startTime;
			int expectedEndTime = 2359;
			int actualEndTime = data.getData()[0].endTime;

			Assert::AreEqual(expectedStartTime, actualStartTime);
			Assert::AreEqual(expectedEndTime, actualEndTime);
		}

		TEST_METHOD(TimeExtremeTest)
		{
			// TODO: Your test code here
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string input1 = "add 2000-2400 FUNRUN";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			

			int expectedStartTime = 2000;
			int actualStartTime = data.getData()[0].startTime;
			int expectedEndTime = 2000;
			int actualEndTime = data.getData()[0].endTime;

			Assert::AreEqual(expectedStartTime, actualStartTime);
			Assert::AreEqual(expectedEndTime, actualEndTime);
			Assert::IsTrue(data.getData()[0].isFloat);
		}

	};
	
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp





