//@author: a0115871e



	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Category.cpp
	 */

#include "Category.h"

//Identifies category from the input and cuts them out from the string
bool Category::checkForCat(int cat, std::string &cStr, size_t found) {
	_cat = "";
	
	switch(cat) {
		case 0:
			_cat = "WORK    ";
			break;
		case 1:
			_cat = "PERSONAL";
			break;
		case 2:
			_cat = "ERRAND  ";
			break;
		case 3:
			_cat = "GENERAL ";
			break;
		default:
			return false;
	}
	extractRemainingStr(cStr, found);
	return true;
}

//Cuts out the identified category
void Category::extractRemainingStr(std::string &cStr, size_t found) {
	if (found == cStr.size()) {
		cStr = "";
		return;
	}
	found = cStr.find_first_not_of(" ", found);
	if (found == std::string::npos) {
		cStr = "";
	}
	else {
		cStr = cStr.substr(found);
	}
	return;
}

std::string &Category::getCat() {
	return _cat;
}

	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Category.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Category.h
	 */

#ifndef CATEGORY_H
#define CATEGORY_H

#include "DataStore.h"

class Category {
	private:
		std::string _cat;

	public:
		Category() {};

		bool checkForCat(int, std::string &, size_t);
		void extractRemainingStr(std::string &, size_t);

		std::string &getCat();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Category.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Delete.cpp
	 */

#include "Delete.h"

bool Delete::deleteContent(DataStore &data, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, bool &isDelete) {
	if (info[0] >= '0' && info[0] <= '9') {
		isDelete = true;
		return deleteByIndex(data, info, errMsg, floating, scheduled, deadline);
	}
	
	return deleteBySubject(data, info, errMsg, floating, scheduled, deadline, isDelete);
}

bool Delete::deleteByIndex(DataStore &data, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline) {
	size_t found = info.find_first_of(" ");
	int index = 0;
	bool isTemp = true;
	std::vector <int> checkList;
	data.getTempData().clear();

	while (!info.empty()) {
		if (found == std::string::npos) {
			found = info.size();
		}
		index = atoi(info.substr(0, found).c_str());
		if (index > data.getTempIndexList().size()) {
			errMsg << "index out of range";
			return false;
		}
		else if (!checkList.empty()) {
			if (isRepeat(data, checkList, index)) {
				errMsg << data.get_tempEntry().subject;
				return false;
			}
		}
		data.get_tempEntry() = data.getData()[data.getTempIndexList()[index - 1]];
		add.addContent(data, errMsg, floating, scheduled, deadline, isTemp);
		checkList.push_back(data.getData()[data.getTempIndexList()[index - 1]].referenceNo);
		if (found == info.size()) {
			info = "";
		}
		else {
			info = info.substr(found + 1);
			found = info.find_first_of(" ");
		}
	}
	remove(data, checkList);
	search.getTempDisplay(data, floating, scheduled, deadline, errMsg);
	checkDataBaseEmpty(data, errMsg);
	return true;
}

bool Delete::deleteBySubject(DataStore &data, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, bool &isDelete) {
	size_t found = 0;
	bool isTemp = true;
	std::vector <int> checkList;
	data.getTempData().clear();

	if (info == "all") {
		deleteAll(data, errMsg, floating, scheduled, deadline, isDelete);
		return true;
	}
	
	data.get_tempEntry().subject = info;
	search.getSubjectSearch(data, floating, scheduled, deadline, errMsg);
	data.get_tempEntry() = data.get_emptyEntry();


	if (data.getTempData().empty()) {
		isDelete = true;
		errMsg << "no same/similar subject found in file";
		return false;
	}
	else if (data.getTempData().size() == 1) {
		checkList.push_back(data.getData()[data.getTempIndexList()[0]].referenceNo);
		remove(data, checkList);
		isDelete = true;
		checkDataBaseEmpty(data, errMsg);
		return true;
	}
	checkDataBaseEmpty(data, errMsg);
	return false;
}



void Delete::deleteAll(DataStore &data, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, bool &isDelete) {
	bool isTemp = true;
	std::vector <int> checkList;

	for (int i = 0; i < data.getTempIndexList().size(); i++) {
		checkList.push_back(data.getData()[data.getTempIndexList()[i]].referenceNo);
		data.get_tempEntry() = data.getData()[data.getTempIndexList()[i]];
		add.addContent(data, errMsg, floating, scheduled, deadline, isTemp);
	}
	remove(data, checkList);
	data.clearData(floating, scheduled, deadline);
	data.get_tempEntry() = data.get_emptyEntry();
	search.getTempDisplay(data, floating, scheduled, deadline, errMsg);
	checkDataBaseEmpty(data, errMsg);
	isDelete = true;
	return;
}

void Delete::remove(DataStore &data, std::vector <int> list) {
	data.getTempIndexList().clear();
	bool isTemp = true;
	
	for (int i = 0; !list.empty(); i++) {
		if (i < data.getData().size() && data.getData()[i].referenceNo == list.back()) {
			data.getTempIndexList().push_back(i);
			data.getData().erase(data.getData().begin() + i);
			list.pop_back();
		}
		
		if (i == data.getData().size()) {
			i = -1;
		}
	}
	return;
}

bool Delete::isRepeat(DataStore &data, std::vector <int> list, int index) {
	for (int j = 0; j < list.size(); j++) {
		if (list[j] == data.getData()[index - 1].referenceNo) {
			data.get_tempEntry().subject = "repeated index to delete found";
			return true;
		}
	}
	return false;
}

void Delete::checkDataBaseEmpty(DataStore &data, std::ostringstream &errMsg) {
	if (data.getData().empty()) {
		errMsg << std::endl << std::endl << " last entry has been cleared";
	}
	return;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Delete.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Delete.h
	 */

#ifndef DELETE_H
#define DELETE_H

#include "DataStore.h"
#include "Search.h"
#include "Add.h"

class Delete {
	private:
		Add add;
		Search search;

	public:
		Delete() {};

		bool deleteContent(DataStore &, std::string, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, bool &);
		
		bool deleteByIndex(DataStore &, std::string, std::ostringstream &,std::ostringstream &, std::ostringstream &, std::ostringstream &);
		bool deleteBySubject(DataStore &, std::string, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, bool &);
		
		void deleteAll(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, bool &);
		void remove(DataStore &, std::vector <int>);
		
		bool isRepeat(DataStore &, std::vector <int>, int);
		void checkDataBaseEmpty(DataStore &, std::ostringstream &);

		int &getIndex();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Delete.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Edit.cpp
	 */

#include "Edit.h"

bool Edit::checkAll(DataStore &data, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, std::string input) {
	int size = 0;
	std::vector <Entry> holdTempTask;

	while (size < data.getTempData().size()) {
		if (input == "uncheck" || input == "uncomplete") {
			data.getData()[data.getTempIndexList()[size]].isComplete = false;
			data.get_tempEntry().subject = "uncompleted all of the below";
		}
		else {
			data.getData()[data.getTempIndexList()[size]].isComplete = true;
			data.get_tempEntry().subject = "completed all of the below";
		}
		size++;
	}
	data.clearData(errMsg, floating, scheduled);
	data.clearData(floating, scheduled, deadline);
	search.getTempDisplay(data, floating, scheduled, deadline, errMsg);
	return true;
}

bool Edit::checkComplete(DataStore &data, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, std::string input) {
	size_t found = info.find_first_of(" ");
	int index = 0;
	std::vector <int> checkList;
	std::vector <Entry> holdTempTask;

	//To complete all tasks shown
	if (info == "all") {
		return checkAll(data, errMsg, floating, scheduled, deadline, input);
	}

	std::cout << "size: " << data.getTempIndexList().size()<<std::endl;
	while (!info.empty()) {
		if (found == std::string::npos) {
			found = info.size();
		}
		index = atoi(info.substr(0, found).c_str());
		if (index > data.getTempData().size()) {
			errMsg << "index out of range";
			return false;
		}
		else if (!checkList.empty()) {
			if (isRepeat(data, checkList, index - 1)) {
				errMsg << data.get_tempEntry().subject;
				return false;
			}
		}
		if (input == "uncheck" || input == "uncomplete") {
			data.getData()[data.getTempIndexList()[index - 1]].isComplete = false;
		}
		else {
			data.getData()[data.getTempIndexList()[index - 1]].isComplete = true;
		}
		checkList.push_back(data.getData()[data.getTempIndexList()[index - 1]].referenceNo);
		if (found == info.size()) {
			info = "";
		}
		else {
			info = info.substr(found + 1);
			found = info.find_first_of(" ");
		}
	}
	updateTemp(data, checkList);
	holdTempTask = data.getTempData();
	sort.sortComplete(data);
	data.getTempData() = holdTempTask;
	std::cout << data.getTempData().size() << std::endl;
	data.clearData(floating, scheduled, deadline);
	search.getTempDisplay(data, floating, scheduled, deadline, errMsg);
	data.get_tempEntry().subject = "completed";
	return true;
}



bool Edit::editContent(DataStore &data, std::vector <int> editCat, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, std::string input, int index) {
	if (data.getData().size() == 0) {
		errMsg << "file is empty";
		return false;
	}
	
	bool real = true;
	bool isTemp = false;
	
	if (input == "check" || input == "done" || input == "complete" || input == "completed" || input == "uncheck" || input == "uncomplete") {
		return checkComplete(data, info, errMsg, floating, scheduled, deadline, input);
	}

	if (index < 0 && !getEditIndex(info, index) && data.getTempData().size() != 1) {
		errMsg << "no index entered";
		return false;
	}
	
	if (index < 0 && data.getTempData().size() == 1) {
		index = 1;
	}
	
	if (errMsg != "") {
		errMsg << "\n";
	}
	
	data.get_tempEntry().subject = info;
	data.getTempData().clear();
	data.getTempData().push_back(data.get_tempEntry());
	
	switch (editCat[0]) {
		case 0:
			if (data.get_tempEntry().subject == "") {
				break;
			}
			errMsg << " \"" << data.getData()[data.getTempIndexList()[index]].subject << "\" to \"";
			errMsg << data.get_tempEntry().subject << "\"";
			data.getData()[data.getTempIndexList()[index]].subject = data.get_tempEntry().subject;
			_editEntry = data.get_tempEntry();
			break;

		case 1:
			errMsg << " \"" << search.getDate(data, data.getTempIndexList()[index], isTemp) << "\" to \"";
			errMsg << search.getDate(data, 0, real) << "\"";
			editDate(data, data.getTempIndexList()[index]);
			_editEntry = data.getTempData().front();
			add.addContent(data, errMsg, floating, scheduled, deadline, isTemp);
			index = 0;
			break;

		case 2:
			errMsg << " \"" << search.getTime(data, data.getTempIndexList()[index], isTemp) << "\" to \"";
			errMsg << search.getTime(data, 0, real) << "\"";
			editTime(data, data.getTempIndexList()[index]);
			_editEntry = data.getTempData().front();
			add.addContent(data, errMsg, floating, scheduled, deadline, isTemp);
			index = 0;
			break;
		    
		case 3:
			errMsg << " \"" << data.getData()[data.getTempIndexList()[index]].priority << "\" to \"";
			errMsg << data.get_tempEntry().priority << "\"";
			data.getData()[data.getTempIndexList()[index]].priority = data.get_tempEntry().priority;
			_editEntry = data.get_tempEntry();
			break;
			
		case 4:
			errMsg << " \"" << data.getData()[data.getTempIndexList()[index]].category << "\" to \"";
			errMsg << data.get_tempEntry().category << "\"";
			data.getData()[data.getTempIndexList()[index]].category = data.get_tempEntry().category;
			_editEntry = data.get_tempEntry();
			break;

		default:
			return false;
	}

	data.get_tempEntry() = data.getData()[data.getTempIndexList()[index]];
	data.clearData(floating, scheduled, deadline);
	search.getEntry(data, floating, scheduled, deadline, errMsg);
	data.get_tempEntry().subject = "";

	if (editCat.size() > 1) {
		index = 0;
		data.get_tempEntry() = _editEntry;
		_editEntry = data.getTempData().front();
		editCat.erase(editCat.begin());
		editContent(data, editCat, info, errMsg, floating, scheduled, deadline, input, index);
	}
	return true;
}

bool Edit::getEditIndex(std::string &info, int &index) {
	
	size_t found = info.find_first_of("0123456789");
	std::string checkNum = info;
	index = 0;
	while (found != std::string::npos && found < checkNum.size() && checkNum[found] >= '0' && checkNum[found] <= '9') {
		index = (index * 10) + (checkNum[found] - '0');
		checkNum = checkNum.substr(found + 1);
	}
	
	if (index != 0) {
		found = info.find_first_of("0123456789");
		info = info.substr(0, found) + checkNum;
		while (info.size() != 0 && info[0] == ' ') {
			info = info.substr(1);
		}
		while (info.size() != 0 && info.back() == ' ') {
			info = info.substr(0, info.size() - 1);
		}
		index--;
		return true;
	}
	else {
		return false;
	}
}

void Edit::editTime(DataStore &data, int index) {
	_editEntry = data.getData()[index];
	
	if (data.get_tempEntry().startTime != data.get_tempEntry().endTime && !_editEntry.isFloat) {
		_editEntry.isTimedTask = true;
	}
	else {
		_editEntry.isTimedTask = false;
	}
			
	_editEntry.startTime = data.get_tempEntry().startTime;
	_editEntry.endTime = data.get_tempEntry().endTime;
	data.getData().erase(data.getData().begin() + index);
	data.get_tempEntry() = _editEntry;
	return;
}

void Edit::editDate(DataStore &data, int index) {
	_editEntry = data.getData()[index];
	if (data.get_tempEntry().day == 0) {
		_editEntry.isFloat = true;
	}
	else {
		_editEntry.isFloat = false;
	}
	_editEntry.day = data.get_tempEntry().day;
	_editEntry.month = data.get_tempEntry().month;
	_editEntry.year = data.get_tempEntry().year;
	data.getData().erase(data.getData().begin() + index);
	data.get_tempEntry() = _editEntry;
	return;
}



void Edit::updateTemp(DataStore &data, std::vector <int> list) {
	data.getTempData().clear();
	data.getTempIndexList().clear();
		
	for (int i = 0; !list.empty(); i++) {
		if (i < data.getData().size() && data.getData()[i].referenceNo == list.back()) {
			data.getTempIndexList().push_back(i);
			data.getTempData().push_back(data.getData()[i]);
			list.pop_back();
		}
		
		if (i == data.getData().size()) {
			i = -1;
		}
	}
	return;
}

bool Edit::isRepeat(DataStore &data, std::vector <int> list, int index) {
	for (int j = 0; j < list.size(); j++) {
		if (list[j] == data.getData()[index].referenceNo) {
			data.get_tempEntry().subject = "repeated index to check complete found";
			return true;
		}
	}
	return false;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Edit.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Edit.h
	 */

#ifndef EDIT_H
#define EDIT_H

#define MIN -1

#include "DataStore.h"
#include "Add.h"
#include "Search.h"
#include "Sort.h"

class Edit {
	private:
		Entry _editEntry;

		Add add;
		Search search;
		Sort sort;

	public:
		Edit() {};
		
		bool checkAll(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::string);
		bool checkComplete(DataStore &, std::string, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::string);
		
		bool editContent(DataStore &, std::vector <int>, std::string, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::string, int = MIN);
		bool getEditIndex(std::string &, int &);
		void editTime(DataStore &, int);
		void editDate(DataStore &, int);
		
		void updateTemp(DataStore &, std::vector <int>);
		bool isRepeat(DataStore &, std::vector <int>, int);
		

};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Edit.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Entry.h
	 */

#ifndef ENTRY_H
#define ENTRY_H

#include <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>
#include <sstream>
#include <stdio.h>
#include <fstream>
#include <assert.h>
#include <time.h>
#include <stdlib.h>
#include <stddef.h>
#include <windows.h>
#include <wchar.h>

class Entry {
	public:
		int referenceNo;

		std::string subject;
		int day;
		int month;
		int year;
		int startTime;
		int endTime;
		std::string priority;
		std::string category;
		bool isTimedTask;
		bool isComplete;
		bool isFloat;
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Entry.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Priority.cpp
	 */

#include "Priority.h"

//Identifies category from the input and cuts them out from the string
bool Priority::checkForPriority(int impt, std::string &pStr, size_t found) {
	_priority = "";

	switch (impt) {
		case 0:
			_priority = "LOW ";
			break;
		case 1:
			_priority = "MED ";
			break;
		case 2:
			_priority = "HIGH";
			break;
		default:
			return false;
	}
	extractRemainingStr(pStr, found);
	return true;
}



//Cuts out if priority is identified
void Priority::extractRemainingStr(std::string &pStr, size_t found) {
	if (found == pStr.size()) {
		pStr = "";
		return;
	}
	found = pStr.find_first_not_of(" ", found);
	if (found == std::string::npos) {
		pStr = "";
	}
	else {
		pStr = pStr.substr(found);
	}
	return;
}



std::string &Priority::getPriority() {
	return _priority;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Priority.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Priority.h
	 */

#ifndef PRIORITY_H
#define PRIORITY_H

#include "DataStore.h"

class Priority {
	private:
		std::string _priority;

	public:
		Priority() {};

		bool checkForPriority(int, std::string &, size_t);
		
		void extractRemainingStr(std::string &, size_t);

		std::string &getPriority();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Priority.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp
	 */

#include "Parser.cpp"
#include "Log.cpp"
#include "Date.cpp"
#include "Edit.cpp"
#include "FileLocation.cpp"
#include "Search.cpp"
#include "Sort.cpp"
#include "Timing.cpp"
//#include "UserInterface.cpp"
#include "UserMessage.cpp"
#include "Priority.cpp"
#include "DataStore.cpp"
#include "Delete.cpp"
#include "Clear.cpp"
#include "Add.cpp"
#include "Classes.cpp"
#include "Category.cpp"
#include "ParserFacade.cpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ListFulTest {		
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp
	 */

	TEST_CLASS(ListFulSortTest) {
	public:
		//Test for sorting by subject
		//According to floating, scheduled, deadline tasks
		TEST_METHOD(SortSubjectTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			int actualOutputInt = 0;
			int actualOutputInt2 = 0;
			int actualOutputInt3 = 0;
			int actualOutputInt4 = 0;
			int actualOutputInt5 = 0;
			int actualOutputInt6 = 0;
			int actualOutputInt7 = 0;
			int actualOutputInt8 = 0;
			int actualOutputInt9 = 0;
			int actualOutputInt10 = 0;
			
			std::string buffer = "buffer";
			std::string input1 = "add b";
			std::string input2 = "add a";
			std::string input3 = "add c";

			std::string input4 = "add c 5 may";
			std::string input5 = "add a 5/5/2015";
			std::string input6 = "add b may 5";
			
			std::string input7 = "add a 5 pm to 6pm 6aug";
			std::string input8 = "add c 6th August 2015 5:00-6:00";
			std::string input9 = "add b 6/8/15 from 5 to 6";
			
			parseF.init(input1);
			actualOutputInt = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			actualOutputInt2 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			actualOutputInt3 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			actualOutputInt4 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input5);
			actualOutputInt5 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input6);
			actualOutputInt6 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input7);
			actualOutputInt7 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input8);
			actualOutputInt8 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input9);
			actualOutputInt9 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			parseF.init("sort sub");
			actualOutputInt10 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			int extectedOutputInt = 0;
			int extectedOutputInt2 = 4;

			std::string expectedSubject1 = "a";
			std::string expectedSubject2 = "b";
			std::string expectedSubject3 = "c";

			std::string actualSubject1 = data.getData()[0].subject;
			std::string actualSubject2 = data.getData()[1].subject;
			std::string actualSubject3 = data.getData()[2].subject;
			std::string actualSubject4 = data.getData()[3].subject;
			std::string actualSubject5 = data.getData()[4].subject;
			std::string actualSubject6 = data.getData()[5].subject;
			std::string actualSubject7 = data.getData()[6].subject;
			std::string actualSubject8 = data.getData()[7].subject;
			std::string actualSubject9 = data.getData()[8].subject;

			Assert::AreEqual(extectedOutputInt, actualOutputInt);
			Assert::AreEqual(extectedOutputInt, actualOutputInt2);
			Assert::AreEqual(extectedOutputInt, actualOutputInt3);
			Assert::AreEqual(extectedOutputInt, actualOutputInt4);
			Assert::AreEqual(extectedOutputInt, actualOutputInt5);
			Assert::AreEqual(extectedOutputInt, actualOutputInt6);
			Assert::AreEqual(extectedOutputInt, actualOutputInt7);
			Assert::AreEqual(extectedOutputInt, actualOutputInt8);
			Assert::AreEqual(extectedOutputInt, actualOutputInt9);

			Assert::AreEqual(extectedOutputInt2, actualOutputInt10);
	
			Assert::AreEqual(expectedSubject1, actualSubject1);
			Assert::AreEqual(expectedSubject2, actualSubject2);
			Assert::AreEqual(expectedSubject3, actualSubject3);
			Assert::AreEqual(expectedSubject1, actualSubject4);
			Assert::AreEqual(expectedSubject2, actualSubject5);
			Assert::AreEqual(expectedSubject3, actualSubject6);
			Assert::AreEqual(expectedSubject1, actualSubject7);
			Assert::AreEqual(expectedSubject2, actualSubject8);
			Assert::AreEqual(expectedSubject3, actualSubject9);

			//Test for dataStore functionality
			int ExpectedDataBaseSize = 9;
			int actualDataBaseSize = data.getData().size();
			Assert::AreEqual(ExpectedDataBaseSize, actualDataBaseSize);
		}

		//Test for sorting by category
		//According to floating, scheduled, deadline tasks
		TEST_METHOD(SortCategoryTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			int actualOutputInt = 0;
			int actualOutputInt2 = 0;
			int actualOutputInt3 = 0;
			int actualOutputInt4 = 0;
			int actualOutputInt5 = 0;
			int actualOutputInt6 = 0;
			int actualOutputInt7 = 0;
			int actualOutputInt8 = 0;
			int actualOutputInt9 = 0;
			int actualOutputInt10 = 0;
			int actualOutputInt11 = 0;
			int actualOutputInt12 = 0;
			int actualOutputInt13 = 0;
			
			std::string buffer = "buffer";
			std::string input1 = "add b GENERAL";
			std::string input2 = "add a WORK";
			std::string input3 = "add c PERSONAL";
			std::string input4 = "add d ERRAND";

			std::string input5 = "add c ERRAND 5 may";
			std::string input6 = "add a WORK 5/5/2015";
			std::string input7 = "add b GENERAL may 5";
			std::string input8 = "add b PERSONAL may 5";
			
			std::string input9 = "add a PERSONAL 5 pm to 6pm 6aug";
			std::string input10 = "add c ERRAND 6th August 2015 5:00-6:00";
			std::string input11 = "add b GENERAL 6/8/15 from 5 to 6";
			std::string input12 = "add b WORK 6/8/15 from 5 to 6";
			
			parseF.init(input1);
			actualOutputInt = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			actualOutputInt2 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			actualOutputInt3 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			actualOutputInt4 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input5);
			actualOutputInt5 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input6);
			actualOutputInt6 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input7);
			actualOutputInt7 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input8);
			actualOutputInt8 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input9);
			actualOutputInt9 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input10);
			actualOutputInt10 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input11);
			actualOutputInt11 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input12);
			actualOutputInt12 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init("sort cat");
			actualOutputInt13 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			int extectedOutputInt = 0;
			int extectedOutputInt2 = 4;

			std::string expectedCategory1 = "WORK    ";
			std::string expectedCategory2 = "PERSONAL";
			std::string expectedCategory3 = "ERRAND  ";
			std::string expectedCategory4 = "GENERAL ";

			std::string actualCategory1 = data.getData()[0].category;
			std::string actualCategory2 = data.getData()[1].category;
			std::string actualCategory3 = data.getData()[2].category;
			std::string actualCategory4 = data.getData()[3].category;
			std::string actualCategory5 = data.getData()[4].category;
			std::string actualCategory6 = data.getData()[5].category;
			std::string actualCategory7 = data.getData()[6].category;
			std::string actualCategory8 = data.getData()[7].category;
			std::string actualCategory9 = data.getData()[8].category;
			std::string actualCategory10 = data.getData()[9].category;
			std::string actualCategory11 = data.getData()[10].category;
			std::string actualCategory12 = data.getData()[11].category;

			Assert::AreEqual(extectedOutputInt, actualOutputInt);
			Assert::AreEqual(extectedOutputInt, actualOutputInt2);
			Assert::AreEqual(extectedOutputInt, actualOutputInt3);
			Assert::AreEqual(extectedOutputInt, actualOutputInt4);
			Assert::AreEqual(extectedOutputInt, actualOutputInt5);
			Assert::AreEqual(extectedOutputInt, actualOutputInt6);
			Assert::AreEqual(extectedOutputInt, actualOutputInt7);
			Assert::AreEqual(extectedOutputInt, actualOutputInt8);
			Assert::AreEqual(extectedOutputInt, actualOutputInt9);
			Assert::AreEqual(extectedOutputInt, actualOutputInt10);
			Assert::AreEqual(extectedOutputInt, actualOutputInt11);
			Assert::AreEqual(extectedOutputInt, actualOutputInt12);

			Assert::AreEqual(extectedOutputInt2, actualOutputInt13);
	
			Assert::AreEqual(expectedCategory1, actualCategory1);
			Assert::AreEqual(expectedCategory2, actualCategory2);
			Assert::AreEqual(expectedCategory3, actualCategory3);
			Assert::AreEqual(expectedCategory4, actualCategory4);
			Assert::AreEqual(expectedCategory1, actualCategory5);
			Assert::AreEqual(expectedCategory2, actualCategory6);
			Assert::AreEqual(expectedCategory3, actualCategory7);
			Assert::AreEqual(expectedCategory4, actualCategory8);
			Assert::AreEqual(expectedCategory1, actualCategory9);
			Assert::AreEqual(expectedCategory2, actualCategory10);
			Assert::AreEqual(expectedCategory3, actualCategory11);
			Assert::AreEqual(expectedCategory4, actualCategory12);

			//Test for dataStore functionality
			int ExpectedDataBaseSize = 12;
			int actualDataBaseSize = data.getData().size();
			Assert::AreEqual(ExpectedDataBaseSize, actualDataBaseSize);
		}

		//Test for sorting by priority
		//According to floating, scheduled, deadline tasks
		TEST_METHOD(SortPriorityTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			int actualOutputInt = 0;
			int actualOutputInt2 = 0;
			int actualOutputInt3 = 0;
			int actualOutputInt4 = 0;
			int actualOutputInt5 = 0;
			int actualOutputInt6 = 0;
			int actualOutputInt7 = 0;
			int actualOutputInt8 = 0;
			int actualOutputInt9 = 0;
			int actualOutputInt10 = 0;
			
			std::string buffer = "buffer";
			std::string input1 = "add b MED";
			std::string input2 = "add a LOW";
			std::string input3 = "add c HIGH";

			std::string input4 = "add c HIGH 5 may";
			std::string input5 = "add a MED 5/5/2015";
			std::string input6 = "add b LOW may 5";
			
			std::string input7 = "add a LOW 5 pm to 6pm 6aug";
			std::string input8 = "add c HIGH 6th August 2015 5:00-6:00";
			std::string input9 = "add b MED 6/8/15 from 5 to 6";
			
			parseF.init(input1);
			actualOutputInt = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			actualOutputInt2 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			actualOutputInt3 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			actualOutputInt4 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input5);
			actualOutputInt5 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input6);
			actualOutputInt6 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input7);
			actualOutputInt7 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input8);
			actualOutputInt8 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input9);
			actualOutputInt9 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init("sort priority");
			actualOutputInt10 = parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
				
			int extectedOutputInt = 0;
			int extectedOutputInt2 = 4;

			std::string expectedPriority1 = "HIGH";
			std::string expectedPriority2 = "MED ";
			std::string expectedPriority3 = "LOW ";

			std::string actualPriority1 = data.getData()[0].priority;
			std::string actualPriority2 = data.getData()[1].priority;
			std::string actualPriority3 = data.getData()[2].priority;
			std::string actualPriority4 = data.getData()[3].priority;
			std::string actualPriority5 = data.getData()[4].priority;
			std::string actualPriority6 = data.getData()[5].priority;
			std::string actualPriority7 = data.getData()[6].priority;
			std::string actualPriority8 = data.getData()[7].priority;
			std::string actualPriority9 = data.getData()[8].priority;

			Assert::AreEqual(extectedOutputInt, actualOutputInt);
			Assert::AreEqual(extectedOutputInt, actualOutputInt2);
			Assert::AreEqual(extectedOutputInt, actualOutputInt3);
			Assert::AreEqual(extectedOutputInt, actualOutputInt4);
			Assert::AreEqual(extectedOutputInt, actualOutputInt5);
			Assert::AreEqual(extectedOutputInt, actualOutputInt6);
			Assert::AreEqual(extectedOutputInt, actualOutputInt7);
			Assert::AreEqual(extectedOutputInt, actualOutputInt8);
			Assert::AreEqual(extectedOutputInt, actualOutputInt9);

			Assert::AreEqual(extectedOutputInt2, actualOutputInt10);
	
			Assert::AreEqual(expectedPriority1, actualPriority1);
			Assert::AreEqual(expectedPriority2, actualPriority2);
			Assert::AreEqual(expectedPriority3, actualPriority3);
			Assert::AreEqual(expectedPriority1, actualPriority4);
			Assert::AreEqual(expectedPriority2, actualPriority5);
			Assert::AreEqual(expectedPriority3, actualPriority6);
			Assert::AreEqual(expectedPriority1, actualPriority7);
			Assert::AreEqual(expectedPriority2, actualPriority8);
			Assert::AreEqual(expectedPriority3, actualPriority9);

			//Test for dataStore functionality
			int ExpectedDataBaseSize = 9;
			int actualDataBaseSize = data.getData().size();
			Assert::AreEqual(ExpectedDataBaseSize, actualDataBaseSize);
		}
		
	};
	
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp
	 */

	TEST_CLASS(ListFulClearTest) {
	public:
	
		TEST_METHOD(ClearTest)
		{
			// TODO: Your test code here
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string buffer = "buffer";
			std::string input1 = "add 2000-2359 FUNRUN";
			std::string input2 = "add doctor appointment may 10th PERSONAL MED";
			std::string input3 = "add runNUS 24 aug 8.30am to 10am MED PERSONAL";
			std::string input4 = "clear";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			Assert::IsTrue(data.getData().empty());
		}

		TEST_METHOD(UndoTest)
		{
			// TODO: Your test code here
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string buffer = "buffer";
			std::string input1 = "add CS project meeting 6 apr 2015 1200-1600 MED";
			std::string input2 = "add visit grandma 5th april 1200-1600 LOW";
			std::string input3 = "add FUNRUN  7th apr 1200-1600";
			std::string input4 = "undo";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			int actualSize = data.getData().size();
			int expectedSize = 2;

			Assert::AreEqual(expectedSize, actualSize);
		}

		TEST_METHOD(RedoTest)
		{
			// TODO: Your test code here
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string buffer = "buffer";
			std::string input1 = "add CS project meeting 6 apr 2015 1200-1600 MED";
			std::string input2 = "add visit grandma 5th april 1200-1600 LOW";
			std::string input3 = "add FUNRUN  7th apr 1300-1700";
			std::string input4 = "undo";
			std::string input5 = "redo";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			parseF.init(input5);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			int actualSize = data.getData().size();
			int expectedSize = 3;

			Assert::AreEqual(expectedSize, actualSize);

			int expectedStartTime = 1300;
			int actualStartTime = data.getData()[2].startTime;
			int expectedEndTime = 1700;
			int actualEndTime = data.getData()[2].endTime;

			Assert::AreEqual(expectedStartTime, actualStartTime);
			Assert::AreEqual(expectedEndTime, actualEndTime);		
		}
	};
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp





