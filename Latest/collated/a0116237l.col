//@author: a0116237l



	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Clear.cpp
	 */

#include "Clear.h"

bool Clear::clearFile(DataStore &data) {
	if (data.getData().size() == 0) {
		return false;
	}
	data.getData().clear();
	return true;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Clear.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Clear.h
	 */

#ifndef CLEAR_H
#define CLEAR_H

#include "DataStore.h"

class Clear {
	public:
		Clear() {};

		bool clearFile(DataStore &);
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Clear.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\MAIN.cpp
	 */

#include "UserInterface.h"

int main() {
	UserInterface listful;
	listful.runProgram();
	return 0;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\MAIN.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Search.cpp
	 */

#include "Search.h"

const int Search::FLOAT_SUB_SIZE = 44;
const int Search::NON_FLOAT_SUB_SIZE = 31;

bool Search::displayContent(DataStore &data, std::string info, std::ostringstream &errMsg, std::ostringstream &floating, 
							std::ostringstream &scheduled, std::ostringstream &deadline) {
	assert(!info.empty());
	data.clearData(floating, scheduled, deadline);
	if (info == "today" || info == "tdy" || info == "tday" || info == "later" || info == "tonight") {
		getToday(data, floating, scheduled, deadline, errMsg);
	}
	else if (info == "tomorrow" || info == "tmr" || info == "tomoro" || info == "tmrw") {
		getTmr(data, floating, scheduled, deadline, errMsg);
	}
	else if (info == "over" || info == "overdue" || info == "undo" || info == "yesterday") {
		getOverDue(data, floating, scheduled, deadline, errMsg);
	}
	else if (info == "done" || info == "complete" || info == "completed" || info == "finished" || info == "finish") {
		getComplete(data, floating, scheduled, deadline, errMsg);
	}
	else if (info == "remind" || info == "reminder" || info == "due") {
		getReminder(data, floating, scheduled, deadline, errMsg);
	}
	else if (info == "float" || info == "to do") {
		getFloat(data, floating, errMsg);
	}
	else if (info == "scheduled" || info == "schedule" || info == "time table" || info == "plan") {
		getScheduled(data, scheduled, errMsg);
	}
	else if (info == "deadline" || info == "due") {
		getDeadline(data, deadline, errMsg);
	}
	else if (info == "all") {
		return isDisplayEmpty(data, errMsg, floating, scheduled, deadline);
	}
	else if (isAllNum(info)) {
		getFullString(info, data, errMsg, floating, scheduled, deadline);
	}
	else {
		return false;
	}

	if (data.getTempData().size() == 0) {
		return false;
	}
	return true;
}

bool Search::isAllNum(std::string info) {
	assert(!info.empty());
	while (info.size() != 0 && info[0] >= '0' && info[0] <= '9') {
		info = info.substr(1);
	}

	if (info.size() == 0) {
		return true;
	}
	return false;
}



void Search::updateDisplayData(DataStore &data, int i) {
	data.getTempData().push_back(data.getData()[i]);
	data.getTempIndexList().push_back(i);
}



void Search::getFloat(DataStore &data, std::ostringstream &floating, std::ostringstream &errMsg) {
	int i = 0;
	std::ostringstream ignore;
	bool updateFile = false;
	data.getTempIndexList().clear();
	data.getTempData().clear();
	
	while (i < data.getData().size() && !data.getData()[i].isComplete && data.getData()[i].isFloat) {
		updateDisplayData(data, i);
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no to do tasks are found";
		return;
	}
	stringGetter(data, floating, ignore, ignore);
	return;
}

void Search::getScheduled(DataStore &data, std::ostringstream &scheduled, std::ostringstream &errMsg) {
	int i = 0;
	std::ostringstream ignore;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();
	
	while (i < data.getData().size()) {
		if (!data.getData()[i].isComplete && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
			updateDisplayData(data, i);
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no scheduled tasks are found";
		return;
	}
	stringGetter(data, ignore, scheduled, ignore);
	return;
}

void Search::getDeadline(DataStore &data, std::ostringstream &deadline, std::ostringstream &errMsg) {
	int i = 0;
	std::ostringstream ignore;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();

	while (i < data.getData().size()) {
		if (!data.getData()[i].isComplete && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
			updateDisplayData(data, i);
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no deadline tasks are found";
		return;
	}
	stringGetter(data, ignore, ignore, deadline);
	return;
}



void Search::getToday(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					  std::ostringstream &errMsg) {
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);
	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday) && data.getData()[i].month == (now.tm_mon + 1) && 
				data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday) && data.getData()[i].month == (now.tm_mon + 1) && 
				data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday) && data.getData()[i].month == (now.tm_mon + 1) && 
				data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due today";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getTmr(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					std::ostringstream &errMsg) {
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);
	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday + 1) && data.getData()[i].month == (now.tm_mon + 1) && 
				data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday + 1) && data.getData()[i].month == (now.tm_mon + 1) && data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == (now.tm_mday + 1) && data.getData()[i].month == (now.tm_mon + 1) && data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due tomorrow";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}



void Search::getComplete(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
						 std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();
	
	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no completed tasks found";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getReminder(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline,
						 std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	bool updateFile = false;
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);
	data.getTempData().clear();
	data.getTempIndexList().clear();
	
	while (i < data.getData().size() && data.getData()[i].isFloat) {
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].year == (now.tm_year + 1900) && data.getData()[i].month == (now.tm_mon + 1) && 
				((data.getData()[i].day - (now.tm_mday) < 3) && (data.getData()[i].day - (now.tm_mday) >= 0))) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].year == (now.tm_year + 1900) && data.getData()[i].month == (now.tm_mon + 1) && 
				((data.getData()[i].day - (now.tm_mday) < 3) && (data.getData()[i].day - (now.tm_mday) >= 0))) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due for the next three days";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getOverDue(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
						std::ostringstream &errMsg) {
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);
	int i = 0;
	data.getTempData().clear();
	data.getTempIndexList().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].year <= (now.tm_year + 1900) && data.getData()[i].month <= (now.tm_mon + 1) && 
				data.getData()[i].day < (now.tm_mday)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if(data.getData()[i].year <= (now.tm_year + 1900) && data.getData()[i].month <= (now.tm_mon + 1) && data.getData()[i].day < (now.tm_mday)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks are overdue";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}



bool Search::getRemainingStr(std::string &cutOff, std::string &remaining, int count) {
	if (remaining.size() > count) {
		cutOff = remaining.substr(0, count);
		remaining = remaining.substr(count);
		return true;
	}
	return false;
}

void Search::getFullString(std::string info, DataStore &data, std::ostringstream &errMsg, std::ostringstream &floating, 
						   std::ostringstream &scheduled, std::ostringstream &deadline) {
	int num = 0;
	bool updateFile = false;
	bool isTemp = true;
	std::string cutOff = "";

	num = atoi(info.c_str());
	if (num > data.getTempData().size()) {
		data.getTempData().clear();
		errMsg << "index out of range";
		return;
	}
	num--;
	std::string remainingStr = data.getTempData()[num].subject;
	
	if (data.getTempData()[num].isFloat) {
		floating << " 1. ";
		if (getRemainingStr(cutOff, remainingStr, FLOAT_SUB_SIZE)) {
			floating << cutOff << " | " << getTime(data, num, isTemp) << " | " << data.getTempData()[num].category;
			floating << " | " << data.getTempData()[num].priority << std::endl;
			while (getRemainingStr(cutOff, remainingStr, FLOAT_SUB_SIZE)) {
				printSpace(floating, 4);
				while (cutOff[0] == ' ') {
					cutOff = cutOff.substr(1);
				}
				floating << cutOff;
				printSpace(floating, FLOAT_SUB_SIZE - cutOff.size());
				floating << " |           |          | " << std::endl;
			}
			printSpace(floating, 4);
			while (remainingStr[0] == ' ') {
				remainingStr = remainingStr.substr(1);
			}
			floating << remainingStr;
			printSpace(floating, FLOAT_SUB_SIZE - remainingStr.size());
			floating << " |           |          | " << std::endl;
		}
		else if (data.getTempData().size() < FLOAT_SUB_SIZE) {
			floating << getTempDataString(data, num, updateFile, 1) << std::endl;
		}
	}
	else if (data.getTempData()[num].isTimedTask) {
		scheduled << " 1. ";
		if (getRemainingStr(cutOff, remainingStr, NON_FLOAT_SUB_SIZE)) {
			scheduled << cutOff << " | " << getDate(data, num, isTemp) << " | " << getTime(data, num, isTemp);
			scheduled << " | " << data.getTempData()[num].category << " | " << data.getTempData()[num].priority << std::endl;
			while (getRemainingStr(cutOff, remainingStr, NON_FLOAT_SUB_SIZE)) {
				printSpace(scheduled, 4);
				while (cutOff[0] == ' ') {
					cutOff = cutOff.substr(1);
				}
				scheduled << cutOff;
				printSpace(scheduled, NON_FLOAT_SUB_SIZE - cutOff.size());
				scheduled << " |            |           |          | " << std::endl;
			}
			printSpace(scheduled, 4);
			while (remainingStr[0] == ' ') {
				remainingStr = remainingStr.substr(1);
			}
			scheduled << remainingStr;
			printSpace(scheduled, NON_FLOAT_SUB_SIZE - remainingStr.size());
			scheduled << " |            |           |          | " << std::endl;
		}
		else if (data.getTempData().size() < NON_FLOAT_SUB_SIZE) {
			scheduled << getTempDataString(data, num, updateFile, 1) << std::endl;
		}
	}
	else {
		deadline << " 1. ";
		if (getRemainingStr(cutOff, remainingStr, NON_FLOAT_SUB_SIZE)) {
			deadline << cutOff << " | " << getDate(data, num, isTemp) << " | " << getTime(data, num, isTemp);
			deadline << " | " << data.getTempData()[num].category << " | " << data.getTempData()[num].priority << std::endl;
			while (getRemainingStr(cutOff, remainingStr, NON_FLOAT_SUB_SIZE)) {
				printSpace(deadline, 5);
				while (cutOff[0] == ' ') {
					cutOff = cutOff.substr(1);
				}
				deadline << cutOff;
				printSpace(deadline, NON_FLOAT_SUB_SIZE - cutOff.size());
				deadline << " |            |           |          | " << std::endl;
			}
			printSpace(deadline, 4);
			while (remainingStr[0] == ' ') {
				remainingStr = remainingStr.substr(1);
			}
			deadline << remainingStr;
			printSpace(deadline, NON_FLOAT_SUB_SIZE - remainingStr.size());
			deadline << " |            |           |          | " << std::endl;
		}
		else if (data.getTempData().size() < NON_FLOAT_SUB_SIZE) {
			deadline << getTempDataString(data, num, updateFile, 1) << std::endl;
		}
	}
	data.get_tempEntry() = data.getTempData()[num];
	data.getTempData().clear();
	int i = 0;
	while (data.get_tempEntry().referenceNo != data.getData()[data.getTempIndexList()[i]].referenceNo) {
		i++;
	}
	i = data.getTempIndexList()[i];
	data.getTempIndexList().clear();
	data.getTempData().push_back(data.get_tempEntry());
	data.getTempIndexList().push_back(i);
	return;
}

void Search::getEntry(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					  std::ostringstream &errMsg) {
	int i = 0;
	bool updateFile = false;
	data.getTempIndexList().clear();
	data.getTempData().clear();
	
	while (i < data.getData().size()) {
		if (data.getData()[i].referenceNo == data.get_tempEntry().referenceNo) {
			if (data.getData()[i].isFloat) {
				floating << " 1. " << getDataString(data, i, updateFile, 1) << std::endl;
				updateDisplayData(data, i);
				return;
			}
			else if (data.getData()[i].isTimedTask) {
				scheduled << " 1. " << getDataString(data, i, updateFile, 1) << std::endl;
				updateDisplayData(data, i);
				return;
			}
			else {
				deadline << " 1. " << getDataString(data, i, updateFile, 1) << std::endl;
				updateDisplayData(data, i);
				return;
			}
		}
		i++;
	}
}



void Search::getMonth(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					  std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	time_t t = time(0);   
	struct tm now;
	localtime_s(&now, &t);
	std::string dayMonth[13] = {"", "January", "February", "March", "April", "May", "June", "July", "August", "September", 
								"October", "November", "December"};
	
	bool updateFile = false;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].month ==  data.get_tempEntry().month && data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].month ==  data.get_tempEntry().month && data.getData()[i].year == (now.tm_year + 1900)) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due in " << dayMonth[data.get_tempEntry().month];
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getSubjectSearch(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
							  std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	size_t found = 0;
	std::string subject = "";
	std::string searchStr = data.get_tempEntry().subject;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			subject = data.getData()[i].subject;
			date.changeToLower(subject);
			date.changeToLower(searchStr);
			found = subject.find(searchStr);
			if (found != std::string::npos) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			subject = data.getData()[i].subject;
			date.changeToLower(subject);
			date.changeToLower(searchStr);
			found = subject.find(searchStr);
			if (found != std::string::npos) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			subject = data.getData()[i].subject;
			date.changeToLower(subject);
			date.changeToLower(searchStr);
			found = subject.find(searchStr);
			if (found != std::string::npos) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}
	if (data.getTempData().size() == 0) {
		errMsg << "no tasks found containing \"" << data.get_tempEntry().subject << "\"";
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getPriority(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
						 std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].priority == data.get_tempEntry().priority) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].priority == data.get_tempEntry().priority) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].priority == data.get_tempEntry().priority) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks found with priority " << data.get_tempEntry().priority;
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getCat(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].category == data.get_tempEntry().category) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].category == data.get_tempEntry().category) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].category == data.get_tempEntry().category) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks found under the category " << data.get_tempEntry().category;
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getTime(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					 std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {				
			if (data.getData()[i].day == data.get_tempEntry().day && data.getData()[i].month ==  data.get_tempEntry().month && 
				data.getData()[i].year ==  data.get_tempEntry().year) {
				if (data.getData()[i].startTime <= data.get_tempEntry().startTime && data.getData()[i].endTime > data.get_tempEntry().startTime) {
					updateDisplayData(data, i);
				}
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == data.get_tempEntry().day && data.getData()[i].month ==  data.get_tempEntry().month && 
				data.getData()[i].year ==  data.get_tempEntry().year) {
				if (data.getData()[i].startTime <= data.get_tempEntry().startTime && data.getData()[i].endTime > data.get_tempEntry().startTime) {
					updateDisplayData(data, i);
				}
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due on " << data.get_tempEntry().day << '/' << data.get_tempEntry().month << '/' << data.get_tempEntry().year;
		errMsg << " at " << data.get_tempEntry().startTime;
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

void Search::getDay(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
					std::ostringstream &errMsg) {
	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempIndexList().clear();
	data.getTempData().clear();

	while (i < data.getData().size() && data.getData()[i].isFloat) {
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == data.get_tempEntry().day && data.getData()[i].month ==  data.get_tempEntry().month && 
				data.getData()[i].year ==  data.get_tempEntry().year) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask && !data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			if (data.getData()[i].day == data.get_tempEntry().day && data.getData()[i].month ==  data.get_tempEntry().month && 
				data.getData()[i].year ==  data.get_tempEntry().year) {
				updateDisplayData(data, i);
			}
		}
		i++;
	}

	if (data.getTempData().size() == 0) {
		errMsg << "no tasks due on " << data.get_tempEntry().day << '/' << data.get_tempEntry().month << '/' << data.get_tempEntry().year;
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}



void Search::getTempDisplay(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline, 
							std::ostringstream &errMsg) {
	int i = 0;
	bool updateFile = false;
	
	if (data.getTempData().size() == 0) {
		return;
	}
	stringGetter(data, floating, scheduled, deadline);
	return;
}

//Completed tasks not displayed
bool Search::isDisplayEmpty(DataStore &data, std::ostringstream &errMsg, std::ostringstream &floating, std::ostringstream &scheduled, 
						std::ostringstream &deadline) {
	if (data.getData().empty()) {
		errMsg << "file is empty";
		return false;
	}

	int i = 0;
	int j = 0;
	bool updateFile = false;
	data.getTempData().clear();
	data.getTempIndexList().clear();
	
	while (i < data.getData().size() && data.getData()[i].isFloat) {
		if (!data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	while (i < data.getData().size() && data.getData()[i].isTimedTask) {
		if (!data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	while (i < data.getData().size() && !data.getData()[i].isTimedTask) {
		if (!data.getData()[i].isComplete) {
			updateDisplayData(data, i);
		}
		i++;
	}

	if (data.getTempData().empty()) {
		errMsg << "all tasks are completed";
		return false;
	}
	stringGetter(data, floating, scheduled, deadline);
	return true;
}



std::string Search::getDataString(DataStore &data, int index, bool updateFile, int index2) {
	std::ostringstream dataString;
	bool isTemp = false;

	if (data.getData()[index].isFloat) {
		if (data.getData().size() > 9 && index2 < 1) {
			printSub(data, dataString, FLOAT_SUB_SIZE - 1, index, updateFile, isTemp);
		}
		else {
			printSub(data, dataString, FLOAT_SUB_SIZE, index, updateFile, isTemp);
		}
	}
	else {
		if (data.getData().size() > 9 && index2 < 0) {
			printSub(data, dataString, NON_FLOAT_SUB_SIZE - 1, index, updateFile, isTemp);
		}
		else {
			printSub(data, dataString, NON_FLOAT_SUB_SIZE, index, updateFile, isTemp);
		}
		dataString << " | ";
		printDate(data, dataString, index, isTemp);
	}
	dataString << " | ";
	printTime(data, dataString, index, isTemp);
	dataString << " | ";
	printCat(data, dataString, index, isTemp);
	dataString << " | ";
	printPriority(data, dataString, index, isTemp);
	return dataString.str();
}

std::string Search::getTempDataString(DataStore &data, int index, bool updateFile, int index2) {
	std::ostringstream dataString;
	bool isTemp = true;

	if (data.getTempData()[index].isFloat) {
		if  (data.getTempData().size() > 9 && index2 < 1) {
			printSub(data, dataString, FLOAT_SUB_SIZE - 1, index, updateFile, isTemp);
		}
		else {
			printSub(data, dataString, FLOAT_SUB_SIZE, index, updateFile, isTemp);
		}
	}
	else {
		if (data.getTempData().size() > 9 && index2 < 1) {
			printSub(data, dataString, NON_FLOAT_SUB_SIZE - 1, index, updateFile, isTemp);
		}
		else {
			printSub(data, dataString, NON_FLOAT_SUB_SIZE, index, updateFile, isTemp);
		}
		dataString << " | ";
		printDate(data, dataString, index, isTemp);
	}
	dataString << " | ";
	printTime(data, dataString, index, isTemp);
	dataString << " | ";
	printCat(data, dataString, index, isTemp);
	dataString << " | ";
	printPriority(data, dataString, index, isTemp);
	return dataString.str();
}

void Search::stringGetter(DataStore &data, std::ostringstream &floating, std::ostringstream &scheduled, std::ostringstream &deadline) {
	int i = 0;
	bool updateFile = false;

	while (i < data.getTempData().size()) {
		if (data.getTempData().size() > 9 && i < 9) {
			if (data.getTempData()[i].isFloat) {
				floating << "  " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
			else if (data.getTempData().size() > 9 && data.getTempData()[i].isTimedTask) {
				scheduled << "  " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
			else if (data.getTempData().size() > 9 && !data.getTempData()[i].isTimedTask && !data.getTempData()[i].isFloat) {
				deadline << "  " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
		}
		else {
			if (data.getTempData()[i].isFloat) {
				floating << " " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
			else if (data.getTempData()[i].isTimedTask) {
				scheduled << " " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
			else if (!data.getTempData()[i].isTimedTask && !data.getTempData()[i].isFloat) {
				deadline << " " << (i + 1) << ". " << getTempDataString(data, i, updateFile) << std::endl;
			}
		}
		i++;
	}
	return;
}



void Search::printSub(DataStore &data, std::ostringstream &dataString, int count, int index, bool updateFile, bool isTemp) {
	int maxSize = 0;

	if (!isTemp) {
		for (int i = 0; i != data.getData().size(); i++) {
			if (data.getData()[i].subject.size() > maxSize) {
				maxSize = data.getData()[i].subject.size();
			}
		}
		if (data.getData()[index].subject.size() > count && !updateFile) {
			std::string cutOff = data.getData()[index].subject.substr(0, count - 2);
			dataString << cutOff << "..";
		}
		else if (!updateFile) {
			dataString << data.getData()[index].subject;
			printSpace(dataString, count - data.getData()[index].subject.size());
		}
		else if (maxSize > count && updateFile) {
			dataString << data.getData()[index].subject;
			if (data.getData()[index].isFloat) {
				printSpace(dataString, 13);
			}
			printSpace(dataString, maxSize - data.getData()[index].subject.size());
		}
		else if (updateFile) {
			dataString << data.getData()[index].subject;
			printSpace(dataString, count - data.getData()[index].subject.size());
		}
	}
	else if (data.getTempData()[index].subject.size() > count) {
		std::string cutOff = data.getTempData()[index].subject.substr(0, count - 2);
		dataString << cutOff << "..";
	}
	else {
		dataString << data.getTempData()[index].subject;
		printSpace(dataString, count - data.getTempData()[index].subject.size());
	}
	return;
}

void Search::printDate(DataStore &data, std::ostringstream &dataString, int index, bool isTemp) {
	if (!isTemp && !data.getData()[index].isFloat) {
		int nDay = countDigit(data.getData()[index].day);
		int nMonth = countDigit(data.getData()[index].month);
		int nYear = countDigit(data.getData()[index].year);
		
		printZero(nDay, dataString, 2);
		dataString << data.getData()[index].day << '/';	
		printZero(nMonth, dataString, 2);
		dataString << data.getData()[index].month << '/';
		printZero(nYear, dataString, 4);
		dataString << data.getData()[index].year;
	}
	else if (isTemp && !data.getTempData()[index].isFloat) {
		int nDay = countDigit(data.getTempData()[index].day);
		int nMonth = countDigit(data.getTempData()[index].month);
		int nYear = countDigit(data.getTempData()[index].year);
		
		printZero(nDay, dataString, 2);
		dataString << data.getTempData()[index].day << '/';	
		printZero(nMonth, dataString, 2);
		dataString << data.getTempData()[index].month << '/';
		printZero(nYear, dataString, 4);
		dataString << data.getTempData()[index].year;
	}
	else {
		printSpace(dataString, 10);
	}
	return;
}

void Search::printTime(DataStore &data, std::ostringstream &dataString, int index, bool isTemp) {
	if (!isTemp) {
		int sTime = countDigit(data.getData()[index].startTime);
		int eTime = countDigit(data.getData()[index].endTime);

		if (data.getData()[index].startTime == 0 && (data.getData()[index].startTime == data.getData()[index].endTime)) {
			printSpace(dataString, 9);
		}
		else if (data.getData()[index].startTime == data.getData()[index].endTime) {
			printZero(sTime, dataString, 4);
			dataString << data.getData()[index].startTime;
			printSpace(dataString, 5);
		}
		else {
			printZero(sTime, dataString, 4);
			dataString << data.getData()[index].startTime << '-';
			printZero(eTime, dataString, 4);
			dataString << data.getData()[index].endTime;
		}
	}
	else {
		int sTime = countDigit(data.getTempData()[index].startTime);
		int eTime = countDigit(data.getTempData()[index].endTime);

		if (data.getTempData()[index].startTime == 0 && (data.getTempData()[index].startTime == data.getTempData()[index].endTime)) {
			printSpace(dataString, 9);
		}
		else if (data.getTempData()[index].startTime == data.getTempData()[index].endTime) {
			printZero(sTime, dataString, 4);
			dataString << data.getTempData()[index].startTime;
			printSpace(dataString, 5);
		}
		else {
			printZero(sTime, dataString, 4);
			dataString << data.getTempData()[index].startTime << '-';
			printZero(eTime, dataString, 4);
			dataString << data.getTempData()[index].endTime;
		}
	}
	return;
}

void Search::printCat(DataStore &data, std::ostringstream &dataString, int index, bool isTemp) {
	if (!isTemp) {
		dataString << data.getData()[index].category;
	}
	else {
		dataString << data.getTempData()[index].category;
	}
	return;
}

void Search::printPriority(DataStore &data, std::ostringstream &dataString, int index, bool isTemp) {
	if (!isTemp) {
		dataString << data.getData()[index].priority;
	}
	else {
		dataString << data.getTempData()[index].priority;
	}
	return;
}



std::string Search::getDate(DataStore &data, int index, bool isTemp) {
	std::ostringstream dataString;
	printDate(data, dataString, index, isTemp);
	return dataString.str();
}

std::string Search::getTime(DataStore &data, int index, bool isTemp) {
	std::ostringstream dataString;
	printTime(data, dataString, index, isTemp);
	return dataString.str();
}



int Search::countDigit(int num) {
	int count = 0;
	
	if (num == 0) {
		return 1;
	}

	while (num > 0) {
		count++;
		num = num/10;
	}
	return count;
}

//To ensure that the no of digits for time and date are 4 and 2 respectively
void Search::printZero(int num, std::ostringstream &dataString, int count) {
	while (num < count) {
		dataString << '0';
		num++;
	}
	return;
}

//To equalize the columns of each output entry
void Search::printSpace(std::ostringstream &dataString, int count) {
	while (count > 0) {
		dataString << " ";
		count--;
	}
	return;
}



void Search::setColour(int value){
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), value);
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Search.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Search.h
	 */

#ifndef SEARCH_H
#define SEARCH_H 1

#define MIN -1

#include "DataStore.h"
#include "Date.h"

class Search {
	private:
		static const int FLOAT_SUB_SIZE;
		static const int NON_FLOAT_SUB_SIZE;

		Date date;

	public:
		Search() {};
	
		bool displayContent(DataStore &, std::string, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		bool isAllNum(std::string);

		void updateDisplayData(DataStore &, int);

		void getFloat(DataStore &, std::ostringstream &, std::ostringstream &);
		void getScheduled(DataStore &, std::ostringstream &, std::ostringstream &);
		void getDeadline(DataStore &, std::ostringstream &, std::ostringstream &);
		
		void getToday(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getTmr(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);

		void getComplete(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getReminder(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getOverDue(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		
		void getEntry(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);		
		bool getRemainingStr(std::string &, std::string &, int);
		void getFullString(std::string, DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		
		void getMonth(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getSubjectSearch(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getPriority(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getCat(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getDay(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		void getTime(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		
		void getTempDisplay(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
		bool isDisplayEmpty(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &, std::ostringstream &);
	
		std::string getDataString(DataStore &, int, bool, int = MIN);
		std::string getTempDataString(DataStore &, int, bool, int = MIN);
		void stringGetter(DataStore &, std::ostringstream &, std::ostringstream &, std::ostringstream &);

		void printSub(DataStore &, std::ostringstream &, int, int, bool, bool);
		void printDate(DataStore &, std::ostringstream &, int, bool);
		void printTime(DataStore &, std::ostringstream &, int, bool);
		void printCat(DataStore &, std::ostringstream &, int, bool);
		void printPriority(DataStore &, std::ostringstream &, int, bool);
	
		std::string getDate(DataStore &, int, bool);
		std::string getTime(DataStore &, int, bool);

		int countDigit(int);
		void printZero(int, std::ostringstream &, int);
		void printSpace(std::ostringstream &, int);

		void setColour(int);
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Search.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Sort.cpp
	 */

#include "Sort.h"

bool Sort::sortContent(DataStore &data){
	switch (_category) {
		case 0:
			sortSub(data);
			break;
		case 1:
			sortDate(data);
			break;
		case 2:
			sortTime(data);
			break;
		case 3:
			sortPriority(data);
			break;
		case 4:
			sortCat(data);
			break;
		default:
			return false;
	}
	return true;
}



//To swap the entries
void Sort::shiftPos(int &index, int &start, DataStore &data){
	data.getTempData().clear();
	data.getTempIndexList().clear();

	for(int i = 0; i < data.getData().size(); i++){
		if (i < start) {
			data.getTempData().push_back(data.getData()[i]); 
			data.getTempData()[i].referenceNo = i + 1;
		}
		else if(i == start) {
			data.getTempData().push_back(data.getData()[index]);
			data.getTempData()[i].referenceNo = i + 1;
			data.getTempData().push_back(data.getData()[i]); 
			data.getTempData()[i + 1].referenceNo = i + 2;
		}
		else if(i != index) {
			data.getTempData().push_back(data.getData()[i]);
			data.getTempData()[i].referenceNo = i + 2;
		}
	}
	data.getData() = data.getTempData();
	data.getTempData().clear();
}



//Sort alphabetically
void Sort::sortSub(DataStore &data) {
	std::string line1 = "";
	std::string lineSize = "";
	std::string line2 = "";

	for (int iter = 1; iter < data.getData().size(); ++iter) {
		line2 = data.getData()[iter].subject;
		for (int start = 0; start < iter; ++start) {
			if (cmpSame(data, start, iter)) {
				line1 = data.getData()[start].subject;
				compareLineSize(line1, line2, lineSize);
				if (isLargerChar(line1, line2, lineSize)) {
					shiftPos(iter, start, data);
					line2 = data.getData()[iter].subject;
				}
			}
		}
	}
	return;
}

void Sort::compareLineSize(std::string &line1, std::string &line2, std::string &lineSize) {
	if (line1.size() <= line2.size()) {
		lineSize = line1;
	}
	else {
		lineSize = line2;
	}
}

bool Sort::isUpperCase(std::string line1, std::string line2, int index, char &word) {
	if (line2[index] >= 'a' && line2[index] <= 'z') {
		if (line1[index] > line2[index]) {
			return true;
		}
	}
	else if (line2[index] >= 'A' && line2[index] <= 'Z') {
		word = 'a' + (line2[index] - 'A');
		if (line1[index] > word) {
			return true;
		}
	}
	return false;
}

bool Sort::isLargerChar(std::string &line1, std::string &line2, std::string &lineSize) {
	for (int index = 0; index < lineSize.size(); index++) {
		char word = ' ';
		if (line1[index] >= 'a' && line1[index] <= 'z') {
			return isUpperCase(line1, line2, index, word);
		}
		else if (line1[index] >= 'A' && line1[index] <= 'Z') {
			return isUpperCase(line2, line1, index, word);
		}
		else if ((line2[index] >= 'a' && line2[index] <= 'z') || (line2[index] >= 'A' && line2[index] <= 'Z')) {
			return true;
		}
		else if (line1[index] > line2[index]) {
			return true;
		}
		
		if ((index == lineSize.size() - 1) && (lineSize == line2)) {
			if ((word != ' ') && (line1[index] < word)) {
				return false;
			}
			else if ((word == ' ') && (line1[index] < line2[index])) {
				return false;
			}
			else {
				return true;
			}
		}
	}

	return false;
}



void Sort::sortDate(DataStore &data) {
	for (int iter = 1; iter < data.getData().size(); ++iter) {
		for (int start = 0; start < iter; ++start) {
			if (cmpSame(data, start, iter)) {
				if (data.getData()[start].year == data.getData()[iter].year && 
					data.getData()[start].month == data.getData()[iter].month && 
					data.getData()[start].day > data.getData()[iter].day) {
					shiftPos(iter, start, data);
				}
				else if (data.getData()[start].year == data.getData()[iter].year && 
					data.getData()[start].month > data.getData()[iter].month) {
					shiftPos(iter, start, data);
				}
				else if (data.getData()[start].year > data.getData()[iter].year) {
					shiftPos(iter, start, data);
				}
			}
		}
	}
	return;
}



void Sort::sortComplete(DataStore &data) {
	for (int iter = 1; iter < data.getData().size(); ++iter) {
		for (int start = 0; start < iter; ++start) {
			if ((data.getData()[start].isFloat == data.getData()[iter].isFloat) && 
				(data.getData()[iter].isTimedTask == data.getData()[start].isTimedTask)) {
				if (data.getData()[start].isComplete && !data.getData()[iter].isComplete) {
					shiftPos(iter, start, data);
				}
			}
		}
	}
	return;
}



void Sort::sortTime(DataStore &data) {
	for (int iter = 1; iter < data.getData().size(); ++iter) {
		for (int start = 0; start < iter; ++start) {
			if (cmpSame(data, start, iter)) {
				if (data.getData()[start].startTime > data.getData()[iter].startTime) {
					shiftPos(iter, start, data);
				}
				else if (data.getData()[start].startTime == data.getData()[iter].startTime && 
					data.getData()[start].endTime < data.getData()[iter].endTime) {
					shiftPos(iter, start, data);
				}
			}
		}
	}
	return;
}



int Sort::determineCategory(std::string word) {
	if (word == "WORK    ") {
		return catType::WORK;
	}
	else if (word == "PERSONAL") {
		return catType::PERSONAL;
	}
	else if (word == "ERRAND  ") {
		return catType::ERRAND;
	}
	else if (word == "GENERAL ") {
		return catType::GENERAL;
	}
	else {
		return catType::CINVALID;
	}
}

void Sort::sortCat(DataStore &data) {
	for (int iter = 1; iter < data.getData().size(); ++iter) {
		for (int start = 0; start < iter; ++start) {
			if (cmpSame(data, start, iter)) {
				if (determineCategory(data.getData()[start].category) > determineCategory(data.getData()[iter].category)) {	
					shiftPos(iter, start, data);
				}
			}
		}
	}
	return;
}



int Sort::determinePriority(std::string word) {
	if (word == "LOW ") {
		return priorityType::LOW;
	}
	else if (word == "MED ") {
		return priorityType::MEDIUM;
	}
	else if (word == "HIGH") {
		return priorityType::HIGH;
	}
	else {
		return priorityType::PINVALID;
	}
}

void Sort::sortPriority(DataStore &data) {
	for (int iter = 1; iter < data.getData().size(); ++iter) {
		for (int start = 0; start < iter; ++start) {
			if (cmpSame(data, start, iter)) {
				if (determinePriority(data.getData()[start].priority) < determinePriority(data.getData()[iter].priority)) {	
					shiftPos(iter, start, data);
				}
			}
		}
	}
	return;
}



bool Sort::cmpSame(DataStore &data, int start, int iter) {
	if (data.getData()[start].isFloat == data.getData()[iter].isFloat) {
		if (data.getData()[iter].isTimedTask == data.getData()[start].isTimedTask) {
			if (data.getData()[start].isComplete == data.getData()[iter].isComplete) {
				return true;
			}
		}
	}
	return false;
}



int &Sort::getSortCat() {
	return _category;
}
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Sort.cpp





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Sort.h
	 */

#ifndef SORT_H
#define SORT_H

#include "DataStore.h"

class Sort {
	private:
		enum priorityType {
			LOW, MEDIUM, HIGH, PINVALID
		};

		enum catType {
			WORK, PERSONAL, ERRAND, GENERAL, CINVALID
		};

		int _category;

	public:
		Sort() {};

		bool sortContent(DataStore &);
	
		void shiftPos(int &, int &, DataStore &);
	
		void sortSub(DataStore &);
		void compareLineSize(std::string &, std::string &, std::string &);
		bool isLargerChar(std::string &, std::string &, std::string &);
		bool isUpperCase(std::string, std::string, int, char &);
	
		void sortComplete(DataStore &);

		void sortDate(DataStore &);

		void sortTime(DataStore &);

		void sortCat(DataStore &);
		int determineCategory(std::string);

		void sortPriority(DataStore &);
		int determinePriority(std::string);

		bool cmpSame(DataStore & ,int, int);

		int &getSortCat();
};

#endif
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\ListfulDraft\Sort.h





	/**
	 * origin: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp
	 */

	TEST_CLASS(ListFulDeleteTest) {
	public:

		//Test delete by a single index
		TEST_METHOD(DeleteSingleTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string input1 = "add 6 apr 2015 1200-1600 CS project meeting MED";
			std::string input2 = "add 5/4/2015 visit grandma 1745-2135";
			std::string input3 = "add IE2100 homework 7 08/04/2015 1900-1300 HIGH";
			std::string input4 = "display";
			std::string input5 = "delete 1";
			std::string buffer = "buffer";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input5);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			std::string expectednewFirst = "CS project meeting";
			std::string actualnewFirst = data.getData()[0].subject;

			Assert::AreEqual(expectednewFirst, actualnewFirst);
		}

		//Test delete by multiple indexes
		TEST_METHOD(DeleteMultipleTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string input1 = "add 6 apr 2015 1200-1600 CS project meeting MED";
			std::string input2 = "add 5/4/2015 visit grandma 1745-2135";
			std::string input3 = "add IE2100 homework 7 08/04/2015 1900-1300 HIGH";
			std::string input4 = "display";
			std::string input5 = "delete 1 2";
			std::string buffer = "buffer";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input5);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			std::string expectednewFirst = "IE2100 homework 7";
			std::string actualnewFirst = data.getData()[0].subject;

			Assert::AreEqual(expectednewFirst, actualnewFirst);
		}

		//Test delete all
		TEST_METHOD(DeleteAllTest) {
			DataStore data;
			ParserFacade parseF;

			std::ostringstream errMsg;
			std::ostringstream floating;
			std::ostringstream scheduled;
			std::ostringstream deadline;

			bool pastDate = false;
			bool checkTime = false;
			bool isTemp = false;
			bool isDelete = false;

			std::string input1 = "add 6 apr 2015 1200-1600 CS project meeting MED";
			std::string input2 = "add 5/4/2015 visit grandma 1745-2135";
			std::string input3 = "add IE2100 homework 7 08/04/2015 1900-1300 HIGH";
			std::string input4 = "display";
			std::string input5 = "delete all";
			std::string buffer = "buffer";

			parseF.init(input1);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input2);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input3);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			parseF.init(input4);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);
			
			int actualDataSize = data.getData().size();
			int expectedDataSize = 3;
			Assert::AreEqual(expectedDataSize, actualDataSize);
			
			parseF.init(input5);
			parseF.carryOutCommand(data, errMsg, floating, scheduled, deadline);
			data.getUndoActionLog().push_back(buffer);

			int actualDataSize2 = data.getData().size();
			int expectedDataSize2 = 0;
			Assert::AreEqual(expectedDataSize2, actualDataSize2);
		}

	};
	
	// End of segment: C:\Users\yyyueying\Documents\Visual Studio 2012\Projects\Listful\Latest\UnitTest\ListFulTest.cpp





